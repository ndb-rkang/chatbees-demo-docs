// the next line is replaced with a generated object at bundle time
const templateData = global.$SDK;
export default class CreateConnector {
    // prevent stackbit dev from bundling index.js with esbuild by using a random filename since it's already bundled
    integration = import(templateData.integrationImportPath).then((m) => {
        const integration = m.integration;
        const connector = integration.netlifyConnectPlugin;
        if (!connector)
            throw new Error(`No connector found`);
        this._getProjectManageUrl = connector._getProjectManageUrl;
        connector.setRuntimeSupportsCreate();
        return integration;
    });
    // set when dynamically importing the connector
    _getProjectManageUrl = () => ``;
    options = {};
    constructor(args) {
        if (args?.options) {
            this.options = args.options;
        }
    }
    getContentSourceType() {
        // todo
        return templateData.configSlug;
    }
    getProjectId() {
        // todo
        return "1";
    }
    async getVersion() {
        return { interfaceVersion: "0.7.3", contentSourceVersion: "0.1" };
    }
    getProjectEnvironment() {
        // todo
        return "main";
    }
    getProjectManageUrl() {
        return this._getProjectManageUrl();
    }
    // todo make these custom error classes to be thrown from within
    // sync/create/publish/etc
    hasAccess() {
        return Promise.resolve({
            hasPermissions: true,
            hasConnection: true,
        });
    }
    validateDocuments() {
        return Promise.resolve({ errors: [] });
    }
    // for now reset/destroy are not needed
    reset() {
        return Promise.resolve();
    }
    destroy() {
        return Promise.resolve();
    }
    async _getConnector() {
        const integration = await this.integration;
        const connector = integration.netlifyConnectPlugin;
        if (!connector)
            throw new Error(`No connector found`);
        return connector;
    }
    async _getAPIPromises(name) {
        const connector = await this._getConnector();
        return connector.getAPIPromises(name);
    }
    async _getImplementation(name) {
        const connector = await this._getConnector();
        return connector.definedImplementations.get(name);
    }
    async init({ cache }) {
        // wait for Connects init to finish
        const { connect, create } = await this._getAPIPromises("init");
        await connect.promise;
        // send back the Create cache so the SDK can use it to insert & delete
        // documents/assets/etc
        create.resolve(cache);
    }
    async updateDocument(stuff) {
        const update = await this._getImplementation("documents.update");
        if (update) {
            return update(stuff);
        }
        throw new Error("connector.documents({ update: fn }) is not implemented");
    }
    async createDocument(stuff) {
        const create = await this._getImplementation("documents.create");
        if (create) {
            return create(stuff);
        }
        throw new Error("connector.documents({ create: fn }) is not implemented");
    }
    async deleteDocument(stuff) {
        const del = await this._getImplementation("documents.delete");
        if (del) {
            return del(stuff);
        }
        throw new Error("connector.documents({ delete: fn }) is not implemented");
    }
    async publishDocuments(stuff) {
        const publish = await this._getImplementation("documents.publish");
        if (publish) {
            return publish(stuff);
        }
        throw new Error("connector.documents({ publish: fn }) is not implemented");
    }
    async getSchema() {
        const models = await this.getModels();
        const locales = await this.getLocales();
        return {
            models: models || [],
            locales: locales || [],
            context: {},
        };
    }
    async getModels() {
        const { connect, create } = await this._getAPIPromises("model");
        const modelBuilder = await connect.promise;
        try {
            return modelBuilder.toCreateModels();
        }
        catch (e) {
            create.reject(e);
        }
        finally {
            create.resolve();
        }
    }
    async getLocales() {
        return (await this._getConnector())._getLocales();
    }
    async connectSyncFinished() {
        const { connect } = await this._getAPIPromises(`sync`);
        await connect.promise;
        return this._getConnector();
    }
    async getDocuments() {
        return (await this.connectSyncFinished()).restoreAllDocuments();
    }
    async getAssets() {
        return (await this.connectSyncFinished()).restoreAllAssets();
    }
    // programatically replaced with getContentEngineConfig() when building for production
    async uploadAsset() {
        return undefined;
    }
}
