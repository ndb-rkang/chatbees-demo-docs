import { SourceNodesArgs } from "content-engine";
import * as CSITypes from "@stackbit/types";
import { ConnectorRuntimeState, NodesApi, Supports, PlatformType } from "../sdk.js";
import { DefineDocumentArgs, DefineNodeArgs, DefineObjectArgs, DefineUnionArgs, ModelDefinition } from "./definition.js";
export type Define = ModelBuilder["pluginAPI"]["define"];
export type ModelerArgs<InitState> = {
    define: Define;
    cache: SourceNodesArgs["cache"];
    state: InitState;
    platform: PlatformType;
};
export type Modeler<InitState> = (args: ModelerArgs<InitState>, configurationOptions: Record<string, any>) => Promise<void>;
export type Models = {
    [modelName: string]: ModelDefinition["dataAPI"];
    [Symbol.iterator](): IterableIterator<ModelDefinition["dataAPI"]>;
} & Record<string, ModelDefinition["dataAPI"]> & {
    concurrent(count: number, callback: (model: ModelDefinition["dataAPI"]) => Promise<void> | void): Promise<void> | void;
};
export type ModelsIteratorObject = Models;
export declare class ModelBuilder {
    models: Map<string, ModelDefinition>;
    modelDataAPIs: Models;
    complete: boolean;
    sdl: string;
    locales: CSITypes.Locale[];
    typePrefix: string;
    nodesApi: NodesApi;
    createApi?: CSITypes.Cache;
    private supports;
    pascaledNames: Map<string, string>;
    private seenTypePaths;
    private shouldAutoRenameFieldsAndModels;
    constructor({ nodesApi, createApi, supports, }: {
        nodesApi: NodesApi;
        createApi?: CSITypes.Cache;
        supports: Supports;
    });
    get pluginAPI(): {
        define: {
            /**
             * @warning - this is an experimental API. Only use if you know what you're doing
             */
            document: ({ name, label, fields, fieldGroups, cacheFieldName, visitor, }: DefineDocumentArgs) => ModelDefinition;
            /**
             * Defines a node model. Nodes are database records that can be queried by their ID. Defining a type allows you to create and update nodes of that type during the createAllNodes and updateNodes data events.
             */
            nodeModel: ({ name, fields, cacheFieldName, visitor, }: DefineNodeArgs) => ModelDefinition;
            /**
             * Defines an object type. Object types are used to define fields on node models.
             */
            object: ({ name, fields, visitor }: DefineObjectArgs) => ModelDefinition;
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             */
            union: ({ name, types, visitor }: DefineUnionArgs) => ModelDefinition;
            /**
             * @warning this is an experimental API. Only use if you know what you're doing :)
             */
            locales: (locales: CSITypes.Locale[]) => void;
        };
    };
    build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }: {
        modeler: Modeler<any>;
        typePrefix: string;
        cache: SourceNodesArgs["cache"];
        configurationOptions: Record<string, any>;
        state: ConnectorRuntimeState;
        shouldAutoRenameFieldsAndModels?: boolean;
        platform: PlatformType;
    }): Promise<{
        sdl: string;
    }>;
    toCreateModels(): (CSITypes.DataModel<unknown> | CSITypes.ObjectModel<unknown>)[];
    addModel(model: ModelDefinition): this;
    private reset;
    private finalizeModels;
    private setSeenTypePaths;
    private validateModelHarmony;
    private renamePascaledFieldTypes;
    private handleMixedUnionTypes;
    private panicOnUndefinedModels;
}
