import { ModelDefinition, builtInTypes, mappedBuiltinTypes, } from "./definition.js";
import { ModelError } from "./error.js";
export class ModelBuilder {
    models = new Map();
    modelDataAPIs;
    complete = false;
    sdl = ``;
    locales = [];
    typePrefix = ``;
    nodesApi;
    createApi;
    supports;
    // original -> pascal
    pascaledNames = new Map();
    seenTypePaths = new Map();
    shouldAutoRenameFieldsAndModels = true;
    constructor({ nodesApi, createApi, supports, }) {
        this.nodesApi = nodesApi;
        this.createApi = createApi;
        this.supports = supports;
        this.reset();
    }
    get pluginAPI() {
        return {
            define: {
                /**
                 * @warning - this is an experimental API. Only use if you know what you're doing
                 */
                document: ({ name, label, fields, fieldGroups, cacheFieldName, visitor, }) => new ModelDefinition({
                    supports: this.supports,
                    name,
                    label,
                    fields,
                    fieldGroups,
                    kind: `Node`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                    createApi: this.createApi,
                    cacheFieldName,
                    visitor,
                    shouldAutoRenameFieldsAndModels: this.shouldAutoRenameFieldsAndModels,
                }),
                /**
                 * Defines a node model. Nodes are database records that can be queried by their ID. Defining a type allows you to create and update nodes of that type during the createAllNodes and updateNodes data events.
                 */
                nodeModel: ({ name, fields, cacheFieldName, visitor, }) => new ModelDefinition({
                    supports: this.supports,
                    name,
                    fields,
                    kind: `Node`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                    createApi: this.createApi,
                    cacheFieldName,
                    visitor,
                    shouldAutoRenameFieldsAndModels: this.shouldAutoRenameFieldsAndModels,
                }),
                /**
                 * Defines an object type. Object types are used to define fields on node models.
                 */
                object: ({ name, fields, visitor }) => new ModelDefinition({
                    supports: this.supports,
                    name,
                    fields,
                    kind: `Object`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                    createApi: this.createApi,
                    visitor,
                    shouldAutoRenameFieldsAndModels: this.shouldAutoRenameFieldsAndModels,
                }),
                /**
                 * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
                 */
                union: ({ name, types, visitor }) => new ModelDefinition({
                    supports: this.supports,
                    name,
                    types,
                    kind: `Union`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                    createApi: this.createApi,
                    visitor,
                    shouldAutoRenameFieldsAndModels: this.shouldAutoRenameFieldsAndModels,
                }),
                /**
                 * @warning this is an experimental API. Only use if you know what you're doing :)
                 */
                locales: (locales) => {
                    this.locales = locales;
                },
            },
        };
    }
    async build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }) {
        this.reset();
        this.typePrefix = typePrefix;
        this.shouldAutoRenameFieldsAndModels =
            typeof shouldAutoRenameFieldsAndModels === `undefined`
                ? true
                : shouldAutoRenameFieldsAndModels;
        try {
            await modeler({
                define: this.pluginAPI.define,
                cache,
                state,
                platform,
            }, configurationOptions);
        }
        catch (e) {
            console.warn(`Encountered errors while running the connector.model() API:`);
            console.error(e);
            process.exit(1);
        }
        this.validateModelHarmony();
        this.complete = true;
        this.finalizeModels();
        return {
            sdl: this.sdl,
        };
    }
    toCreateModels() {
        const createModels = [];
        if (!this.complete) {
            throw new Error(`Cannot generate Create models before ModelBuilder has built its internal models via ModelBuilder.build()`);
        }
        this.models.forEach((model) => {
            if (model.getTypeName() === `Image`)
                return;
            const createModel = model.toCreateModel();
            if (createModel)
                createModels.push(createModel);
        });
        return createModels;
    }
    // called by the ModelDefinition constructor for all new models that are created while modelDefiner is running in this.build()
    addModel(model) {
        const typeName = model.getTypeName();
        const existingDefinition = this.models.get(typeName);
        if (existingDefinition) {
            throw new Error(`Model with name "${typeName}" was defined more than once. Model names must be unique. The first definition was:\n\n${existingDefinition.toSDL()}`);
        }
        this.models.set(typeName, model);
        if (model.isNodeType) {
            this.modelDataAPIs[typeName] = model.dataAPI;
            // add keys with original input name, ie if name was product_categories, the
            // model name is ProductCategories, but the connector will likely need to fetch
            // and insert data with the original product_categories name
            if (model.getOriginalName() !== typeName) {
                this.modelDataAPIs[model.getOriginalName()] = model.dataAPI;
            }
        }
        return this;
    }
    reset() {
        this.models = new Map();
        this.seenTypePaths = new Map();
        this.modelDataAPIs = {
            async concurrent(count, modelCallback) {
                if (typeof count !== `number`) {
                    throw new ModelError(`models.concurrent(arg1) must be a number`);
                }
                if (count < 1) {
                    throw new ModelError(`models.concurrent(arg1) must be a positive number`);
                }
                if (Math.round(count) !== count) {
                    throw new ModelError(`models.concurrent(arg1) must be a whole number`);
                }
                const models = Array.from(this);
                const slots = Array(count).fill(null);
                function runNextModelInSlot() {
                    const model = models.pop();
                    if (!model)
                        return;
                    const mbePromise = modelCallback(model);
                    if (mbePromise && `then` in mbePromise) {
                        return mbePromise.then(runNextModelInSlot);
                    }
                    else {
                        return runNextModelInSlot();
                    }
                }
                await Promise.all(slots.map(runNextModelInSlot));
            },
        };
        Object.defineProperty(this.modelDataAPIs, Symbol.iterator, {
            value: function* () {
                for (const [name, model] of Object.entries(this)) {
                    if (typeof model === "function")
                        continue; // skip the iterator
                    if (`concurrent` === name)
                        continue; // skip non-model methods
                    if (name === model?.originalName && model.name !== model.originalName)
                        continue; // skip any original name models, these are duplicates added by original name for convinience
                    yield model;
                }
            },
            enumerable: false,
        });
        this.complete = false;
        this.sdl = ``;
    }
    finalizeModels() {
        this.sdl = ``;
        this.models.forEach((model) => {
            model.buildWalker();
            this.sdl += `${model.toSDL()}\n\n`;
        });
        this.sdl = this.sdl.trim();
    }
    // used to track which types have been referenced by other types so we can throw errors (with helpful paths) for undefined types after building models
    setSeenTypePaths() {
        this.models.forEach((model) => {
            const modelTypeName = model.getTypeName();
            if (!this.seenTypePaths.has(modelTypeName)) {
                this.seenTypePaths.set(modelTypeName, [modelTypeName]);
            }
            for (const compositeType of model?.compositeTypes || []) {
                const compositeTypename = model.getDefinedTypeName(compositeType);
                if (!this.seenTypePaths.has(compositeTypename)) {
                    this.seenTypePaths.set(compositeTypename, []);
                }
                this.seenTypePaths.get(compositeTypename).push(`union ${modelTypeName} = ${compositeTypename} | ...`);
            }
            for (const fieldDefinition of model.getFields()) {
                const fieldName = fieldDefinition.name;
                const typeName = model.getDefinedTypeName(fieldDefinition.type, fieldName);
                if (!this.seenTypePaths.has(typeName)) {
                    this.seenTypePaths.set(typeName, []);
                }
                // store a backreference to this type. IE if the field is One.fieldA and fieldA has type Two, then
                // Two => ['One.fieldA', 'OtherType.fieldSomething'] is stored where we keep a list of every place that references this type
                this.seenTypePaths.get(typeName).push(`${modelTypeName}.${fieldName}`);
            }
        });
    }
    validateModelHarmony() {
        this.renamePascaledFieldTypes();
        this.setSeenTypePaths();
        this.panicOnUndefinedModels();
        this.handleMixedUnionTypes();
    }
    renamePascaledFieldTypes() {
        if (!this.pascaledNames.size) {
            return;
        }
        for (const model of this.models.values()) {
            // pascal union/interface type references
            if (model.compositeTypes) {
                let index = -1;
                for (const type of model.compositeTypes) {
                    index++;
                    // Definition objects don't need to be renamed here, only rename strings
                    if (typeof type !== `string`)
                        continue;
                    const pascaled = this.pascaledNames.get(type);
                    if (pascaled) {
                        model.compositeTypes[index] = pascaled;
                        model.compositeTypesSet.delete(type);
                        model.compositeTypesSet.add(pascaled);
                    }
                }
            }
            for (const def of Object.values(model.fields)) {
                const pascaled = this.pascaledNames.get(model.getDefinedTypeName(def.type));
                if (pascaled) {
                    def.type = pascaled;
                }
            }
        }
    }
    handleMixedUnionTypes() {
        for (const model of this.models.values()) {
            if (model.isUnionType && model.compositeTypes) {
                const foundTypes = {
                    node: [],
                    object: [],
                    union: [],
                    scalar: [],
                };
                for (const type of model.compositeTypes) {
                    const typename = model.getDefinedTypeName(type);
                    if (builtInTypes.has(typename)) {
                        foundTypes.scalar.push(typename);
                        continue;
                    }
                    const fullType = this.models.get(typename);
                    if (!fullType)
                        continue;
                    if (fullType.isObjectType)
                        foundTypes.object.push(typename);
                    if (fullType.isNodeType)
                        foundTypes.node.push(typename);
                    if (fullType.isUnionType)
                        foundTypes.union.push(typename);
                }
                if (foundTypes.object.length && foundTypes.scalar.length) {
                    throw new ModelError(`Object and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.object,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                if (foundTypes.node.length && foundTypes.scalar.length) {
                    throw new ModelError(`Node and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.node,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                const isMixedUnion = foundTypes.node.length && foundTypes.object.length;
                if (isMixedUnion && this.supports.create) {
                    throw new ModelError(`Mixed unions (documents and objects) are not supported in Netlify Create. Found: ${[
                        ...foundTypes.node,
                        ...foundTypes.scalar,
                        ...foundTypes.object,
                    ].join(`, `)}`);
                }
                else if (isMixedUnion) {
                    model.setIsMixedUnion();
                }
            }
        }
    }
    panicOnUndefinedModels() {
        const undefinedModelErrors = new Map();
        for (const [seenTypeName, sdlPaths] of this.seenTypePaths.entries()) {
            if (!this.models.has(seenTypeName) &&
                !builtInTypes.has(seenTypeName) &&
                !mappedBuiltinTypes.has(seenTypeName)) {
                if (!undefinedModelErrors.has(seenTypeName)) {
                    undefinedModelErrors.set(seenTypeName, new Set());
                }
                for (const sdlPath of sdlPaths) {
                    undefinedModelErrors.get(seenTypeName).add(sdlPath);
                }
            }
        }
        if (undefinedModelErrors.size > 0) {
            const errorMessages = Array.from(undefinedModelErrors.entries()).map(([typeName, sdlPaths]) => {
                return `Undefined type "${typeName}", referenced on type fields:\n\n${Array.from(sdlPaths.keys())
                    .map((sdlPath) => {
                    return ` - ${sdlPath}`;
                })
                    .join(`\n`)}\n`;
            });
            errorMessages.forEach((message) => {
                console.error(message);
            });
            if (undefinedModelErrors.size > 1) {
                console.error(`There were ${undefinedModelErrors.size} referenced type names which haven't been defined. Either your plugin has a typo or there are types which haven't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            else {
                console.error(`There was 1 referenced type name which hasn't been defined. Either your plugin has a typo or there is a type which hasn't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            setTimeout(() => {
                // leave a little time for large errors to print
                process.exit(1);
            }, 100);
        }
    }
}
