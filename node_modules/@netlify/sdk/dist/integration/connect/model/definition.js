import camelcase from "camelcase";
// We need this one as it's the one that is used in the content-engine
import _ from "lodash";
import { lmdbStoredAssetToStackbit, lmdbStoredDocumentToStackbit, } from "../utils/data.js";
import { ModelWalker } from "./walker.js";
import { ModelError } from "./error.js";
export const builtInStackbitStringTypes = new Set([
    // todo: make sure the SDK checks that these are strings when validating input data
    "Slug",
    "Url",
    "Text",
    "Markdown",
]);
export const builtInStackbitTypes = new Set([
    ...builtInStackbitStringTypes.keys(),
    // todo: handle enums as GraphQL enums
    // "enum",
    // todo: how should cross-reference be handled? we need a custom resolver most likely
    // "cross-reference",
    // these are already handled by content-engine types
    // "boolean",
    // "date",
    // "datetime",
    // "number",
    // "reference",
]);
// todo - this should be imported from content-engine
export const builtInTypes = new Set([
    ...builtInStackbitStringTypes.keys(),
    `ID`,
    `String`,
    `Int`,
    `Float`,
    `Boolean`,
    `JSON`,
    `Date`,
]);
export const mappedBuiltinTypes = new Map([
    ...Array.from(builtInTypes).map((type) => {
        return [type.toLowerCase(), type];
    }),
    // additional mappings
    [`integer`, `Int`],
    [`number`, `Float`],
]);
export const builtInScalars = new Set([
    ...Array.from(builtInTypes),
    ...mappedBuiltinTypes.keys(),
]);
export class ModelDefinition {
    compositeTypes = [];
    compositeTypesSet = new Set();
    description;
    cacheFieldName;
    ModelWalker;
    ModelBuilder;
    visitor;
    camelToOriginalNames = new Map();
    originalToCamelNames = new Map();
    fields = [];
    fieldsMap = new Map();
    fieldGroups;
    definedKind;
    typeName;
    originalName;
    nodesApi;
    createApi;
    isMixedUnion = false;
    label;
    shouldAutoRenameFieldsAndModels = true;
    supports;
    constructor(input) {
        this.typeName = input.name;
        this.definedKind = input.kind;
        this.description = input.description;
        this.compositeTypes = input.types;
        this.nodesApi = input.nodesApi;
        this.createApi = input.createApi;
        this.visitor = input.visitor;
        this.label = input.label;
        this.supports = input.supports;
        this.shouldAutoRenameFieldsAndModels =
            input.shouldAutoRenameFieldsAndModels;
        this.processInputDefinition(input);
        this.ModelWalker = new ModelWalker({
            model: this,
            getModelByName: this.getModelByName,
        });
        this.ModelBuilder = input.ModelBuilder.addModel(this);
        return this;
    }
    getFields() {
        return this.fields;
    }
    getTypeName() {
        return this.typeName;
    }
    getOriginalName() {
        return this.originalName || this.typeName;
    }
    get isNodeType() {
        return this.definedKind === `Node`;
    }
    get isObjectType() {
        return this.definedKind === `Object`;
    }
    get isUnionType() {
        return this.definedKind === `Union`;
    }
    getDefinedTypeName(type, fieldName) {
        const isDefineInstance = type instanceof ModelDefinition;
        const typeName = isDefineInstance ? type.typeName : type;
        if (typeof typeName === `undefined`) {
            throw new ModelError(`The type of field "${fieldName}" is undefined. Please define the type of this field.`);
        }
        return typeName;
    }
    prefixedTypeName(typeName = this.typeName) {
        if (builtInTypes.has(typeName)) {
            return typeName;
        }
        return `${this.ModelBuilder.typePrefix}${typeName}`;
    }
    getFinalFieldName(fieldName, unionModelName) {
        if (!this.shouldAutoRenameFieldsAndModels)
            return fieldName;
        const model = unionModelName ? this.getModelByName(unionModelName) : this;
        if (unionModelName &&
            this.isUnionType &&
            model &&
            !this.compositeTypesSet.has(model.getTypeName())) {
            throw new Error(`${unionModelName} does not exist in union type ${this.getTypeName()}`);
        }
        return model?.originalToCamelNames?.get(fieldName) || fieldName;
    }
    get devOnlyFieldGroup() {
        return process.env.NODE_ENV === `development` && this.isNodeType
            ? {
                name: `netlify-connect`,
                label: `Netlify Connect`,
                icon: `circle-info`,
            }
            : undefined;
    }
    toCreateModel() {
        let fieldGroups = this.fieldGroups;
        if (this.devOnlyFieldGroup) {
            fieldGroups ||= [];
            fieldGroups.push(this.devOnlyFieldGroup);
        }
        // Create doesn't have named union types
        if (this.isUnionType)
            return false;
        const name = this.originalName || this.getTypeName();
        const model = {
            name,
            label: this.label || name,
            type: this.isObjectType ? `object` : `data`,
            fieldGroups,
            fields: this.sdkFieldsToStackbitFields(),
        };
        return model;
    }
    sdkFieldsToStackbitFields() {
        return this.fields.map((field) => {
            const definedTypename = this.getDefinedTypeName(field.type);
            const fieldModel = this.ModelBuilder.models.get(definedTypename);
            const typename = fieldModel?.originalName || definedTypename;
            const isObject = fieldModel?.isObjectType;
            const scalarTypename = isObject
                ? `object`
                : {
                    // create only has a number field
                    float: "number",
                    int: "number",
                }[typename.toLowerCase()] ||
                    // all other scalar types are supported as lowercase typenames
                    typename.toLowerCase();
            const isImage = typename === `Image`;
            const isReference = !isImage && fieldModel?.isNodeType;
            const isUnion = fieldModel?.isUnionType;
            const firstUnionType = isUnion &&
                fieldModel?.compositeTypes &&
                this.ModelBuilder.models.get(this.getDefinedTypeName(fieldModel.compositeTypes[0]));
            const isObjectUnion = firstUnionType && firstUnionType.isObjectType;
            const isReferenceUnion = firstUnionType && firstUnionType.isNodeType;
            const type = (() => {
                if (isObjectUnion)
                    return `model`;
                if (isReference || isReferenceUnion)
                    return `reference`;
                if (isUnion) {
                    throw new ModelError(`Unhandled union type for model ${typename}. This is a bug in the Netlify SDK.`);
                }
                if (isImage)
                    return `image`;
                return scalarTypename;
            })();
            const stackbitField = {
                type,
                name: field.name,
            };
            if (typename.toLowerCase() === `float`) {
                stackbitField.subtype = `float`;
            }
            if (isObject) {
                stackbitField.fields =
                    fieldModel.sdkFieldsToStackbitFields();
            }
            // any field names starting with _ are internal mandatory fields.
            // they shouldn't be set as required in the Create UI as content admins
            // don't need to set these fields, connector authors do.
            if (`required` in field && !field.name.startsWith(`_`)) {
                stackbitField.required = field.required;
            }
            if (`label` in field) {
                stackbitField.label = field.label;
            }
            if (`hidden` in field) {
                stackbitField.hidden = field.hidden;
            }
            if (`readOnly` in field) {
                stackbitField.readOnly = field.readOnly;
            }
            if (`localized` in field) {
                stackbitField.localized = field.localized;
            }
            if (`defaultValue` in field) {
                stackbitField.default = field.defaultValue;
            }
            if (`group` in field) {
                stackbitField.group = field.group;
            }
            if (isUnion) {
                stackbitField.models = (fieldModel.compositeTypes || []).map((ct) => {
                    const fullType = this.getModelByName(this.getDefinedTypeName(ct));
                    return fullType.getOriginalName();
                });
            }
            else if (isReference) {
                stackbitField.models = [
                    fieldModel.getOriginalName(),
                ];
            }
            if (field.list) {
                const { name, required, hidden, ...items } = stackbitField;
                return {
                    name,
                    required,
                    hidden,
                    type: `list`,
                    items,
                };
            }
            else {
                return stackbitField;
            }
        });
    }
    get dataAPI() {
        const walker = this.ModelWalker;
        return {
            name: this.typeName,
            originalName: this.originalName || this.typeName,
            insert: this.insert,
            // needed while unified API is being shipping in small pieces. create is replaced with insert going forward.
            create: this.insert,
            delete: this.delete,
            get fields() {
                return walker.fields;
            },
        };
    }
    buildWalker() {
        return this.ModelWalker.build();
    }
    getModelByName(typeName) {
        return this.ModelBuilder.models.get(this.ModelBuilder.pascaledNames.get(typeName) || typeName);
    }
    hasField(fieldName) {
        return this.fieldsMap.has(fieldName);
    }
    get delete() {
        return (nodeIds) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call delete() on a non-node type. You can only delete nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const deleteNode = this.nodesApi?.deleteNode;
            if (!deleteNode) {
                throw new ModelError(`models.${this.typeName}.delete() can only be called inside createAllNodes or updateNodes Connector events.`);
            }
            const removeNode = (rawId) => {
                const id = this.createNodeId(rawId);
                if (this.createApi?.updateContent) {
                    if (this.typeName === `Image`) {
                        this.createApi.updateContent({
                            deletedAssetIds: [rawId],
                        });
                    }
                    else {
                        this.createApi.updateContent({
                            deletedDocumentIds: [rawId],
                        });
                    }
                }
                return deleteNode({
                    id,
                    internal: {
                        type: this.prefixedTypeName(),
                        contentDigest: `0`,
                    },
                });
            };
            if (Array.isArray(nodeIds)) {
                return nodeIds.map(removeNode);
            }
            return removeNode(nodeIds);
        };
    }
    get insert() {
        return (nodes) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call create() on a non-node type. You can only create nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const createNode = this.nodesApi?.createNode;
            if (!createNode) {
                throw new ModelError(`models.${this.typeName}.insert() can only be called inside documents.sync, createAllNodes, or updateNodes Connector events.`);
            }
            const insertNode = (node) => {
                if (!node)
                    return null;
                // if stackbit is present in this process
                if (this.createApi?.updateContent) {
                    const preparedNode = this.prepareNode(node, `stackbit`);
                    if (this.typeName === `image` || this.typeName === `Image`) {
                        this.createApi.updateContent({
                            assets: [lmdbStoredAssetToStackbit(preparedNode)],
                        });
                    }
                    else {
                        this.createApi.updateContent({
                            documents: [lmdbStoredDocumentToStackbit(preparedNode, this)],
                        });
                    }
                    // if we have stackbit in this process, we store data in stackbit format and use GraphQL aliases to make Connect format resolve properly in GraphQL queries
                    return createNode(preparedNode);
                }
                else {
                    // if there's no stackbit in this process, store data in content-engine/Connect format.
                    return createNode(this.prepareNode(node, `content-engine`));
                }
            };
            if (Array.isArray(nodes)) {
                return nodes.map((node) => insertNode(node));
            }
            return insertNode(nodes);
        };
    }
    createNodeId(rawId) {
        const createNodeId = this.nodesApi?.createNodeId;
        if (!createNodeId) {
            throw new ModelError(`models.${this.typeName}.createNodeId() can only be called inside createAllNodes or updateNodes Connector events.`);
        }
        return createNodeId(`${this.prefixedTypeName()}${rawId}`);
    }
    prepareNode(node, forPackage = `content-engine`) {
        return this.ModelWalker.coerceModelValue(node, [], undefined, undefined, forPackage
        // todo: get the stackbit object type instead of any
        );
    }
    setIsMixedUnion() {
        this.isMixedUnion = true;
    }
    toSDL() {
        const stackbitIsAvailable = !!this.createApi?.updateContent;
        if (this.isUnionType && this.compositeTypes) {
            return `union ${this.prefixedTypeName()} = ${this.compositeTypes
                .map((type) => this.prefixedTypeName(this.getDefinedTypeName(type, this.getTypeName())))
                .join(` | `)}`;
        }
        else if (this.isUnionType) {
            throw new ModelError(`You've defined a union type ("${this.getTypeName()}") but haven't provided any composite types.`);
        }
        // building up SDL strings instead of using type builders in case we want to remove graphql-compose later. definitions are intentionally simple, so model shouldn't be an issue.
        let sdl = ``;
        if (this.description) {
            sdl += `"""${this.description}"""\n`;
        }
        sdl += `type ${this.prefixedTypeName()} `;
        if (this.isNodeType) {
            sdl += `implements Node `;
        }
        sdl += `@dontInfer {\n`;
        this.fields.forEach((fieldType) => {
            const fieldName = fieldType.name;
            const { type, required, list } = fieldType;
            const fieldTypeName = this.getDefinedTypeName(type, fieldName);
            const fieldModel = this.ModelBuilder.models.get(fieldTypeName);
            if (fieldType?.description) {
                sdl += `  """${fieldType.description}"""\n`;
            }
            sdl += `  ${fieldName}: `;
            let fieldSdl = ``;
            if (list) {
                fieldSdl += `[`;
            }
            fieldSdl += this.prefixedTypeName(fieldTypeName);
            if (required) {
                fieldSdl += `!`;
            }
            if (list) {
                fieldSdl += `]`;
            }
            if (list === `required`) {
                fieldSdl += `!`;
            }
            let isNodeType = fieldModel?.isNodeType;
            if (fieldModel?.isUnionType) {
                isNodeType = fieldModel.compositeTypes?.some((type) => {
                    const typeName = this.getDefinedTypeName(type, this.getTypeName());
                    return this.getModelByName(typeName)?.isNodeType;
                });
            }
            // when Stackbit is running in the current process, lmdb nodes are stored in Stackbit format
            // so proxy for that format. In production, nodes are stored in Connect format
            if (stackbitIsAvailable) {
                let proxyField = ``;
                if (isNodeType && fieldModel?.isUnionType) {
                    proxyField = list ? `items._connectId` : `_connectId`;
                }
                else if (isNodeType) {
                    proxyField = list ? `items._connectId` : `_connectId`;
                }
                else if (fieldModel?.isObjectType || fieldModel?.isUnionType) {
                    proxyField = list ? `items.fields` : `fields`;
                }
                else {
                    proxyField = list ? `items.value` : `value`;
                }
                fieldSdl += ` @proxy(from: "${fieldName}.${proxyField}")`;
            }
            if (isNodeType) {
                fieldSdl += ` @link(from: "${fieldName}.id"${fieldModel?.isMixedUnion ? ` keepObjects: true` : ``})`;
            }
            sdl += `${fieldSdl}\n`;
        });
        sdl += `}`;
        return sdl;
    }
    containsIllegalChars(str) {
        return /[^a-zA-Z0-9_]/.test(str);
    }
    processInputDefinitionFields(definition) {
        if (!this.isObjectType && !this.isNodeType) {
            // only object/node types have fields currently
            return;
        }
        if ((!Array.isArray(definition.fields) &&
            typeof definition.fields !== `object`) ||
            !definition.fields) {
            throw new ModelError(`Field definitions must be an array or object, found ${typeof definition.fields} fields in "${definition.name}" definition.`);
        }
        // convert object field definitions to array
        if (!Array.isArray(definition.fields)) {
            this.fields = Object.entries(definition.fields).map(([fieldName, field]) => {
                return {
                    name: fieldName,
                    ...field,
                };
            });
        }
        else if (Array.isArray(definition.fields)) {
            // otherwise use provided array
            this.fields = definition.fields;
        }
        const stackbitIsRunningInThisProcess = !!this.createApi?.updateContent;
        const supportsCreate = this.supports.create;
        const group = this.devOnlyFieldGroup?.name;
        const builtInFields = [
            // connect fields
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_objectId`,
                type: `String`,
                required: true,
                group,
                readOnly: true,
                description: `The original non-global ID from this data source`,
                hidden: process.env.NODE_ENV !== `development`,
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_originalType`,
                type: `String`,
                required: true,
                group,
                readOnly: true,
                description: `The original non-global type name from this data source`,
                hidden: process.env.NODE_ENV !== `development`,
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_connectId`,
                type: `String`,
                hidden: process.env.NODE_ENV !== `development`,
                group,
                required: stackbitIsRunningInThisProcess,
            },
            // create fields
            {
                name: `_updatedAt`,
                type: `Date`,
                required: stackbitIsRunningInThisProcess,
                hidden: true,
            },
            {
                name: `_createdAt`,
                type: `Date`,
                required: stackbitIsRunningInThisProcess,
                hidden: true,
            },
            {
                name: `_status`,
                type: `String`,
                required: stackbitIsRunningInThisProcess,
                hidden: true,
            },
            {
                name: `_manageUrl`,
                type: supportsCreate ? `Url` : `String`,
                hidden: true,
            },
            { name: `_createdBy`, type: `String`, hidden: true },
            { name: `_updatedBy`, type: `String`, list: true, hidden: true },
            { name: `_locale`, type: `String`, hidden: true },
        ];
        if (this.isNodeType) {
            this.fields.push(...builtInFields);
        }
        this.fields.forEach((field) => {
            // don't camelcase or validate builtin fields
            if (!this.isNodeType || !builtInFields.includes(field)) {
                if (this.shouldAutoRenameFieldsAndModels) {
                    const fieldName = field.name;
                    const camelFieldName = _.camelCase(fieldName);
                    if (fieldName !== camelFieldName) {
                        this.camelToOriginalNames.set(camelFieldName, fieldName);
                        this.originalToCamelNames.set(fieldName, camelFieldName);
                        field.name = camelFieldName;
                    }
                }
                this.validateFieldDefinition(field);
            }
            if (this.fieldsMap.has(field.name)) {
                throw new ModelError(`Model field definition with name ${this.getTypeName()}.${field.name} has been defined more than once. Each field name must be unique.`);
            }
            this.fieldsMap.set(field.name, field);
        });
    }
    processInputDefinition(definition) {
        if (this.definedKind !== `Node` && definition.cacheFieldName) {
            throw new ModelError(`You cannot provide a "cacheFieldName" for a non-Node type. "cacheFieldName" is only valid when using define.nodeModel({ ... }). This setting specifies which property on nodes should be used to invalidate each cached node.`);
        }
        if (!definition.name) {
            throw new ModelError(`You must provide a name when defining a type. For example: define.methodName({ name: "MyType", ... })`);
        }
        if (typeof definition.name !== `string`) {
            throw new ModelError(`The name of a model must be a string. For example: define.nodeModel({ name: "MyType", ... })`);
        }
        // For Netlify Create don't camel case model names. In a future release this will become the default, but this is a breaking change for now so do it conditionally.
        if (this.shouldAutoRenameFieldsAndModels) {
            const pascaled = camelcase(definition.name, {
                pascalCase: true,
            });
            if (pascaled !== definition.name) {
                definition.ModelBuilder.pascaledNames.set(definition.name, pascaled);
                this.originalName = definition.name;
                this.typeName = definition.name = pascaled;
            }
        }
        if (this.containsIllegalChars(definition.name)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${definition.name}" is not valid.`);
        }
        if (definition.fieldGroups) {
            // @todo dev runtime validation for field groups would be useful
            this.fieldGroups = definition.fieldGroups;
        }
        this.processInputDefinitionFields(definition);
        this.compositeTypes?.forEach((type) => {
            this.compositeTypesSet.add(this.getDefinedTypeName(type));
        });
        this.cacheFieldName = definition.cacheFieldName;
        if (this.cacheFieldName) {
            const cacheFieldDef = this.fieldsMap.get(this.cacheFieldName);
            if (!cacheFieldDef) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but haven't defined a field with that name.`);
            }
            if (!cacheFieldDef.required) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field is not defined as required. For proper cache invalidation this field must always exist.`);
            }
            if (cacheFieldDef.list) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field type is a list. For proper cache invalidation the cacheFieldName can only be set to a non-list field type.`);
            }
            const cacheFieldTypeName = this.getDefinedTypeName(cacheFieldDef.type);
            if (cacheFieldDef.type !== `String` &&
                mappedBuiltinTypes.get(cacheFieldTypeName) !== `String`) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") For proper cache invalidation the cacheFieldName can only be set to a "String" field type. The "${this.cacheFieldName}" field is of type "${cacheFieldTypeName}".`);
            }
        }
    }
    validateFieldDefinition(fieldDef) {
        const fieldName = fieldDef.name;
        if (typeof fieldName !== `string`) {
            throw new ModelError(`Field names must be strings. "${JSON.stringify(fieldName, null, 2)}" is not a string`);
        }
        if (this.containsIllegalChars(fieldName)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${fieldName}" is not valid.`);
        }
        if (fieldName.match(/^\d/)) {
            throw new ModelError(`Names cannot start with a number. "${fieldName}" is not valid.`);
        }
        if (typeof fieldDef !== `object` || Array.isArray(fieldDef)) {
            throw new ModelError(`Field type definitions must be objects. "${JSON.stringify(fieldDef, null, 2)}" is not an object.`);
        }
        if (typeof fieldDef.type === `string`) {
            const lowercasedBuiltIn = mappedBuiltinTypes.get(fieldDef.type);
            if (lowercasedBuiltIn) {
                fieldDef.type = lowercasedBuiltIn;
            }
        }
        const fieldTypeName = this.getDefinedTypeName(fieldDef.type, fieldName);
        if (typeof fieldTypeName !== `string`) {
            throw new ModelError(`Field definition "${fieldName}.type" must be defined as a string. For ex -> ${fieldName}: { type: "Boolean" }
Instead you have defined it as "${JSON.stringify(fieldTypeName, null, 2)}"`);
        }
        if ([`[`, `]`, `!`].some((char) => fieldTypeName.includes(char))) {
            throw new ModelError(`The type of field "${fieldName}" must not be an SDL string.
For example this is not allowed
  ${fieldName}: { type: "${fieldTypeName}" }
use something like the following instead
  ${fieldName}: { type: "${fieldTypeName
                .replaceAll(`[`, ``)
                .replaceAll(`]`, ``)
                .replaceAll(`!`, ``)}", required: ${fieldTypeName.includes(`!`)}${fieldTypeName.includes(`[`)
                ? `, list: ${fieldTypeName.includes(`]!`) ? `"required"` : `true`}`
                : ``} }`);
        }
        if ([`id`, `internal`, `fields`, `__typename`, `versionId`].includes(fieldName.toLowerCase())) {
            throw new ModelError(`"${fieldName}" is a built-in reserved field name and cannot be redefined, a different field name must be used.`);
        }
        if (this.isUnionType && !this.compositeTypes?.length) {
            throw new ModelError(`You must provide at least one type when defining a union. For example: define.union({ name: "MyUnion", types: ["MyType"] })`);
        }
        if (fieldDef.visitor && typeof fieldDef.visitor !== `function`) {
            throw new ModelError(`Field visitors must be defined as a function. Found ${typeof fieldDef.visitor}`);
        }
        if (`required` in fieldDef &&
            typeof fieldDef.required !== `undefined` &&
            typeof fieldDef.required !== `boolean`) {
            throw new ModelError(`The "required" property in field definitions must either be undefined or a boolean value. Found ${typeof fieldDef.required} for field ${fieldDef.name}`);
        }
    }
}
