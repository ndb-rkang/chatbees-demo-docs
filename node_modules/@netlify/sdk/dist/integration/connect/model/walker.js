import { builtInScalars, } from "./definition.js";
import { ModelError } from "./error.js";
export class ModelWalker {
    model;
    getModelByName;
    coersionFields = [];
    mappedCoersionFields = new Map();
    allowedFieldNames = new Set();
    constructor({ model, getModelByName, }) {
        this.model = model;
        this.getModelByName = getModelByName.bind(this.model);
    }
    build() {
        if (this.model.isNodeType) {
            this.allowedFieldNames.add(`id`);
            const idField = {
                fieldName: `id`,
                fieldTypeName: `ID`,
                required: true,
                list: false,
            };
            this.mappedCoersionFields.set(`id`, idField);
            this.coersionFields.push(idField);
        }
        if (this.model.isUnionType && this.model.compositeTypes) {
            this.allowedFieldNames.add(`__typename`);
            for (const type of this.model.compositeTypes) {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                const typeModel = this.getModelByName(typeName);
                if (!typeModel && !builtInScalars.has(typeName)) {
                    throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.model.getTypeName()}"`);
                }
                if (typeModel?.isNodeType) {
                    this.allowedFieldNames.add(`id`);
                }
                if (typeModel) {
                    for (const { name } of typeModel.getFields()) {
                        this.allowedFieldNames.add(name);
                    }
                }
            }
        }
        for (const fieldDefinition of this.model.getFields()) {
            const fieldName = fieldDefinition.name;
            const fieldTypeName = this.model.getDefinedTypeName(fieldDefinition.type, fieldName);
            const isBuiltInType = builtInScalars.has(fieldTypeName);
            const fieldModel = this.getModelByName(fieldTypeName);
            if (!fieldModel && !isBuiltInType) {
                throw new ModelError(`Could not find model for field type "${fieldTypeName}" in model "${this.model.getTypeName()}"`);
            }
            const unCameled = this.model.camelToOriginalNames.get(fieldName);
            if (unCameled) {
                this.allowedFieldNames.add(unCameled);
            }
            this.allowedFieldNames.add(fieldName);
            const coersionField = {
                fieldName,
                fieldTypeName,
                model: fieldModel,
                required: !!fieldDefinition.required,
                list: fieldDefinition.list || false,
                visitor: fieldDefinition.visitor,
            };
            this.coersionFields.push(coersionField);
            this.mappedCoersionFields.set(fieldName, coersionField);
        }
    }
    fieldByName(name, visitorState) {
        const field = this.mappedCoersionFields.get(name);
        if (!field) {
            throw new Error(`No coersion field found for ${name}`);
        }
        const model = this.model;
        return {
            name: field.fieldName,
            get originalName() {
                return (model.camelToOriginalNames.get(field.fieldName) || field.fieldName);
            },
            typeName: field.fieldTypeName,
            list: field.list,
            required: field.required,
            is: {
                scalar: builtInScalars.has(field.fieldTypeName) || false,
                node: field?.model?.isNodeType || false,
                union: field?.model?.isUnionType || false,
                object: field?.model?.isObjectType || false,
            },
            get fields() {
                return field.model?.ModelWalker?.fields;
            },
            get visitorContext() {
                return visitorState.context;
            },
            setVisitorContext(newValue) {
                visitorState.context = newValue;
            },
        };
    }
    get fields() {
        const fields = {};
        for (const field of this.coersionFields) {
            fields[field.fieldName] = this.fieldByName(field.fieldName, {
                context: null,
            });
        }
        return fields;
    }
    coerceModelValue(modelValue, path = [], combinedType, visitorState = { context: null }, forPackage = `content-engine`) {
        const isRootNode = !path.length;
        let coercedValue = { ...modelValue };
        if (typeof this.model.visitor === `function`) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const walker = this;
            const visitorInfo = {
                setVisitorContext(newContext) {
                    visitorState.context = newContext;
                },
                get fields() {
                    return walker.fields;
                },
                get visitorContext() {
                    return visitorState?.context;
                },
            };
            coercedValue = this.model.visitor(coercedValue, visitorInfo);
        }
        this.setNodeId(coercedValue, path);
        this.throwOnMissingTypename(coercedValue, path);
        if (process.env.NODE_ENV !== `production`) {
            this.throwOnIncorrectUnionTypename(coercedValue, path, combinedType);
            this.throwOnUndefinedModelFields(coercedValue, combinedType);
        }
        const handledUnionValue = this.handleUnionValue(coercedValue, path, visitorState, forPackage);
        if (handledUnionValue)
            return handledUnionValue;
        this.coerceFields(coercedValue, path, visitorState, forPackage);
        this.setInternalProperty(coercedValue, isRootNode);
        return coercedValue;
    }
    setNodeId(coercedValue, path) {
        if (this.model.isNodeType) {
            const rawId = coercedValue.id;
            // If the node is a root node (ie no path yet), we need to add the type name to the path for error messages. ex: "MyModel.foo.bar.id"
            if (!path.length) {
                path.push(`${this.model.getTypeName()}`);
                path.push(`(rawId='${rawId}')`);
            }
            if (!rawId) {
                throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll nodes must have an "id" field which identifies the node.`);
            }
            coercedValue._objectId = rawId;
            coercedValue._originalType = this.model.getOriginalName();
            if (!coercedValue._updatedAt && coercedValue._createdAt) {
                coercedValue._updatedAt = coercedValue._createdAt;
            }
            coercedValue.id = coercedValue._connectId =
                this.model.createNodeId(rawId);
        }
    }
    handleUnionValue(coercedValue, path, visitorState, forPackage = `content-engine`) {
        if (this.model.isUnionType) {
            const asType = this.model.ModelBuilder.pascaledNames.get(coercedValue.__typename) ||
                coercedValue.__typename;
            const asModel = this.getModelByName(asType);
            if (!asModel) {
                throw new ModelError(`Could not find model for union type "${asType}" in model "${this.model.getTypeName()}" at node path "${path.join(`.`)}".\n\nAll union model values must have a "__typename" which identifies the correct type of the provided value. You may have a typo in your "__typename" value or you may need to define the ${asType} model.`);
            }
            if (asModel.isNodeType) {
                const rawId = coercedValue?.id;
                if (!rawId) {
                    throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll node type union model values must have an "id" which identifies the node connection field. The type of the model in this union is "${asModel.getTypeName()}"`);
                }
                const globalId = asModel.createNodeId(rawId);
                if (forPackage === `content-engine`) {
                    coercedValue.id = globalId;
                    delete coercedValue.__typename;
                    coercedValue.internal ||= {};
                    coercedValue.internal.type = asModel.prefixedTypeName();
                }
                else {
                    coercedValue.refId = rawId;
                    coercedValue._connectId = globalId;
                    coercedValue.refType = "document";
                    coercedValue.type = "reference";
                    coercedValue.modelName = asModel.getOriginalName();
                }
                return coercedValue;
            }
            const val = asModel.ModelWalker.coerceModelValue(coercedValue, path, this.model, visitorState, forPackage);
            if (forPackage === `stackbit`) {
                return {
                    type: "object",
                    modelName: asModel.getOriginalName(),
                    fields: val,
                };
            }
            else if (forPackage === `content-engine`) {
                return val;
            }
        }
    }
    coerceFields(coercedValue, path, visitorState, forPackage = `content-engine`) {
        for (const field of this.coersionFields) {
            const uncameled = this.model.camelToOriginalNames.get(field.fieldName);
            if (uncameled && typeof coercedValue[uncameled] !== `undefined`) {
                coercedValue[field.fieldName] = coercedValue[uncameled];
                delete coercedValue[uncameled];
            }
            let modelFieldValue = coercedValue[field.fieldName];
            if (field.visitor) {
                modelFieldValue = coercedValue[field.fieldName] = field.visitor(modelFieldValue, this.fieldByName(field.fieldName, visitorState));
            }
            const isList = field.list === true || field.list === `required`;
            const isRequiredList = field.list === `required`;
            const isEmptyList = !!modelFieldValue && !modelFieldValue?.length;
            const isRelationship = field.model?.isNodeType;
            const fieldMustBeNonNull = field.required || isRequiredList;
            const fieldIsNullOrUndefined = typeof modelFieldValue === `undefined` && modelFieldValue !== null;
            const shouldThrow = (fieldMustBeNonNull && fieldIsNullOrUndefined) ||
                (isRequiredList && isEmptyList);
            const modelString = `Insertion failed validation\n  -> for model "${this.model.getTypeName()}"\n  -> on`;
            const pathString = shouldThrow
                ? `  -> at input path ${path.join(`.`)}.${field.fieldName} <- this field\n  -> required field type "${field.fieldTypeName}${field.list ? `[]` : ``}"\n  -> provided field value:\n    -> ${field.fieldName} is "${JSON.stringify(modelFieldValue, null, 2)}"`.substring(0, 250) + `\n...`
                : undefined;
            if (shouldThrow && isList && isRelationship) {
                throw new ModelError(`${modelString} required list field "${field.fieldName}".\n    -> This field must be an array of strings that are node IDs ${pathString}`);
            }
            else if (shouldThrow && isList) {
                throw new ModelError(`${modelString} required list field "${field.fieldName}" ${pathString}`);
            }
            else if (shouldThrow && isRelationship) {
                throw new ModelError(`${modelString} required field "${field.fieldName}". This field value must be a node id string ${pathString}`);
            }
            else if (shouldThrow) {
                throw new ModelError(`${modelString} required field "${field.fieldName}" ${pathString}`);
            }
            else if (fieldIsNullOrUndefined) {
                continue;
            }
            if (!field.list && field.model?.isNodeType) {
                const rawId = modelFieldValue?.id || modelFieldValue;
                const id = field.model.createNodeId(rawId);
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] = {
                        id,
                        internal: {
                            type: field.model.prefixedTypeName(),
                        },
                    };
                }
                else if (forPackage === `stackbit`) {
                    coercedValue[field.fieldName] = {
                        type: `reference`,
                        refType: field.model.getTypeName() === `Image` ? `asset` : `document`,
                        refId: rawId,
                        _connectId: id,
                    };
                }
                continue;
            }
            else if (field.list && field.model?.isNodeType) {
                const fieldModel = field.model;
                if (!fieldModel) {
                    throw new ModelError(`Could not find model for field type: ${JSON.stringify(field, null, 2)})}`);
                }
                const listItemReferences = modelFieldValue?.map?.((modelFieldValueListItem) => {
                    const rawId = modelFieldValueListItem?.id || modelFieldValueListItem;
                    if (typeof rawId !== `string` &&
                        typeof modelFieldValueListItem !== `undefined`) {
                        throw new ModelError(`Invalid "${this.model.getTypeName()}" input object: ${JSON.stringify(coercedValue, null, 4).replace(`    "${field.fieldName}": `, `--> "${field.fieldName}": `)}\n\nThe value at input path "${path.join(`.`)}.${field.fieldName}${field.list ? `[]` : ``}.id" is not a valid node id string.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
                    }
                    else if (typeof rawId !== `string`) {
                        throw new ModelError(`Invalid "${this.model.getTypeName()}" input object: ${JSON.stringify(coercedValue, null, 4).replace(`    "${field.fieldName}": `, `-->"${field.fieldName}": `)}\n\nThe value at input path "${path.join(`.`)}.${field.fieldName}" is not a valid node id string.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
                    }
                    const id = fieldModel.createNodeId(rawId);
                    if (forPackage === `content-engine`) {
                        return {
                            id,
                            internal: {
                                type: fieldModel.prefixedTypeName(),
                            },
                        };
                    }
                    else if (forPackage === `stackbit`) {
                        return {
                            type: `reference`,
                            refType: fieldModel.getTypeName() === `Image` ? `asset` : `document`,
                            refId: rawId,
                            _connectId: id,
                        };
                    }
                });
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] = listItemReferences;
                }
                else if (forPackage === `stackbit`) {
                    coercedValue[field.fieldName] = {
                        type: `list`,
                        items: listItemReferences,
                    };
                }
                continue;
            }
            if (field.model && !field.list) {
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] =
                        field.model.ModelWalker.coerceModelValue(modelFieldValue, [...path, field.fieldName], undefined, visitorState, `content-engine`);
                }
                else if (forPackage === `stackbit`) {
                    coercedValue[field.fieldName] = {
                        type: `object`,
                        fields: field.model.ModelWalker.coerceModelValue(modelFieldValue, [...path, field.fieldName], undefined, visitorState, `stackbit`),
                    };
                    if (field.model?.isUnionType) {
                        coercedValue[field.fieldName] =
                            coercedValue[field.fieldName].fields;
                    }
                }
                continue;
            }
            else if (field.model && field.list) {
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] = modelFieldValue.map((node, index) => {
                        return field.model.ModelWalker.coerceModelValue(node, [...path, field.fieldName, `[${index}]`], undefined, visitorState, "content-engine");
                    });
                    continue;
                }
                else if (forPackage === `stackbit`) {
                    coercedValue[field.fieldName] = {
                        type: `list`,
                        items: modelFieldValue.map((node, index) => {
                            const fields = field.model.ModelWalker.coerceModelValue(node, [...path, field.fieldName, `[${index}]`], undefined, visitorState, `stackbit`);
                            if (field.model?.isUnionType) {
                                return fields;
                            }
                            return {
                                type: `object`,
                                fields,
                            };
                        }),
                    };
                }
                continue;
            }
            else if (!field.model && field.list && forPackage === `stackbit`) {
                coercedValue[field.fieldName] = {
                    type: `list`,
                    items: modelFieldValue?.map?.((listFieldValue) => {
                        return {
                            type: field.fieldTypeName.toLowerCase(),
                            value: listFieldValue,
                        };
                    }),
                };
                continue;
            }
            if (forPackage === `stackbit` && field.fieldTypeName !== `ID`) {
                const stackbitType = field.model?.dataAPI?.originalName ||
                    {
                        String: `string`,
                        Int: `number`,
                    }[field.fieldTypeName] ||
                    field.fieldTypeName.toLowerCase();
                if (stackbitType === `date` &&
                    coercedValue[field.fieldName] instanceof Date) {
                    coercedValue[field.fieldName] =
                        coercedValue[field.fieldName].toISOString();
                }
                coercedValue[field.fieldName] = {
                    type: stackbitType,
                    value: coercedValue[field.fieldName],
                };
                continue;
            }
        }
    }
    setInternalProperty(coercedValue, isRootNode = false) {
        if (isRootNode) {
            const { cacheFieldName } = this.model;
            const cacheFieldValue = cacheFieldName
                ? coercedValue[cacheFieldName]
                : Math.random();
            if (!cacheFieldValue) {
                throw new ModelError(`A cacheFieldName ("${cacheFieldName}") is defined but the input value at ${this.model.getTypeName()}.${cacheFieldName} is falsy. This value must always be defined and truthy.`);
            }
            coercedValue.internal ||= {};
            coercedValue.internal.contentDigest = String(cacheFieldValue);
            coercedValue.internal.type = this.model.prefixedTypeName();
        }
        else if (coercedValue.__typename) {
            // connection union fields will have a __typename but no cacheFieldName. internal.type needs to be set for content engine resolvers to work
            coercedValue.__typename = this.model.prefixedTypeName();
            coercedValue.internal ||= {};
            coercedValue.internal.type = this.model.prefixedTypeName();
        }
    }
    throwOnMissingTypename(coercedValue, path) {
        if (this.model.isUnionType && !coercedValue.__typename) {
            throw new ModelError(`Union model "${this.model.getTypeName()}" insertion failed validation for required field "__typename".\nAll union model values must have a "__typename" which identifies the type of the provided value.\nThe value at input path "${path.join(`.`)}" is missing a "__typename".`);
        }
    }
    throwOnIncorrectUnionTypename(coercedValue, path, combinedType) {
        if (this.model.isUnionType || combinedType?.isUnionType) {
            const typeIsInUnion = (combinedType || this.model).compositeTypes?.some((type) => {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                const finalTypeName = this.model.ModelBuilder.pascaledNames.get(typeName) || typeName;
                return (finalTypeName === coercedValue.__typename ||
                    this.model.ModelBuilder.pascaledNames.get(coercedValue.__typename) === finalTypeName);
            });
            if (!typeIsInUnion) {
                throw new ModelError(`Union model "${this.model.getTypeName()}" insertion failed validation for required field "__typename".\nThe value at input path "${path.join(`.`)}" has a "__typename" of "${coercedValue.__typename}" but that type is not in the "${(combinedType || this.model).getTypeName()}" union.`);
            }
        }
    }
    throwOnUndefinedModelFields(modelValue, combinedType) {
        // throw for any properties that are not defined as fields on the model
        Object.keys(modelValue || {}).forEach((key) => {
            if (key === `__typename` && combinedType?.isUnionType) {
                return;
            }
            const fieldName = this.model.getFinalFieldName(key, modelValue?.__typename);
            if (!this.allowedFieldNames.has(fieldName)) {
                delete modelValue[key];
            }
        });
    }
}
