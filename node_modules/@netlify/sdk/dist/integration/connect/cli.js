import { resolve, join } from "path";
import { execSync } from "child_process";
import * as url from "url";
import { contentEngine } from "content-engine";
import { outdent as javascript } from "outdent";
import fsExtra from "fs-extra";
import chalk from "chalk";
import { removeBundledDepsFromPackageJsonContents, } from "../../cli/util.js";
import { ntliLog } from "../../utils.js";
const { readFileSync, writeFile, writeJSON, copyFile, ensureDir } = fsExtra;
/**
 * Adds the absolute path of the bundled plugin package.json to the engine config
 * when the engine is started this allows it to use the bundled local plugin.
 */
function getEngineConfigWithBundledPlugin({ integration, path, }) {
    const connectorConfig = integration?.netlifyConnectPlugin?.config || {};
    if (`developmentConfig` in connectorConfig) {
        throw new Error(`developmentConfig has been replaced with localDevOptions. The old config took a list of plugins while the new one takes an object of options for your connector to be used during connector development.`);
    }
    if (`devConfigOptions` in connectorConfig) {
        throw new Error(`devConfigOptions has been renamed to localDevOptions. The functionality has not changed, only the name has.`);
    }
    // specifying the path to a package.json file in the plugins array will cause the plugin to be loaded from that path
    const localPluginPackageJSONPath = resolve(path, `.ntli/connector`, `package.json`);
    const engineConfig = {
        plugins: [
            {
                resolve: localPluginPackageJSONPath,
                options: integration?.netlifyConnectPlugin?.config?.localDevOptions || {},
            },
        ],
    };
    return engineConfig;
}
export async function createDevelopmentContentEngine({ integration, path, }) {
    const engineConfig = getEngineConfigWithBundledPlugin({
        integration,
        path,
    });
    const engineOptions = {
        engineConfig,
        frameworkHooks: integration.netlifyConnectPlugin?.supports?.create
            ? join(path, `/.ntli/connector/content-engine-hooks.cjs`)
            : undefined,
        printLogs: false,
    };
    if (process.env.LOG_LEVEL) {
        engineOptions.env = {
            LOG_LEVEL: process.env.LOG_LEVEL,
        };
    }
    // Set the SDK_ENV because the connector's constructor method 
    // needs context of what platform it is running on.
    // NODE_ENV isn't used because the connector could be running 
    // in a development environment that's not the `netlify-integration` CLI (e.g: Stackbit dev)
    engineOptions.env = {
        ...engineOptions.env || {},
        SDK_ENV: `development`,
    };
    const engine = contentEngine(engineOptions);
    engine.onStdOut((data) => {
        const message = data.toString();
        // don't filter logs when a log level is set
        if (typeof process.env.LOG_LEVEL !== `undefined`) {
            process.stdout.write(message);
            return;
        }
        // temporary log filtering until we add flags to Stackbit/content-engine to turn off certain logs
        for (const logPart of [
            // content-engine
            `Loading plugins - `,
            `Fetching API Data - `,
            `Creating GraphQL schemas - `,
            `[content-engine] starting "`,
            `building schema - `,
            `update integration data - `,
            `[content-engine] initializing`,
            `[content-engine] sync started`,
            `[content-store] Update document`,
            `[content-engine] stopping subprocess`,
            `Clean up stale nodes`,
            ` is ready:`,
            `http://localhost:${chalk.bold(`8000`)}/__graphql`,
            // stackbit dev
            `Open ${chalk.bold(`http://localhost:8090/_stackbit`)} in your browser`,
            "reloading stackbit config from: stackbit.config.js",
            `Server started. Forwarding requests to:`,
            `Content sources found: `,
            `Loaded content source data: `,
            `Site directory: `,
            `Initializing content source: `,
            `Using Content Source Interface`,
            `[content-store] Update document`,
            `[content-store] reset content source`,
        ]) {
            if (message.includes(logPart))
                return;
        }
        process.stdout.write(message);
    });
    engine.onStdErr((data) => {
        const message = data.toString();
        if (message.includes(`has generated no Gatsby nodes. Do you need it?`))
            return;
        process.stderr.write(data);
    });
    return { engine };
}
export const generateConnectPlugin = async (integrationWorker, config, opts) => {
    const { outDir, watchMode } = opts;
    const connectorDir = resolve(outDir, `connector`);
    const contentEngineApiNames = await integrationWorker.implementedConnectorAPINames();
    if (!contentEngineApiNames.length) {
        console.log(chalk.white("No Netlify Connect plugin API's found."));
        return;
    }
    const packageJSONContents = await fsExtra.readJSON(resolve(process.cwd(), `package.json`));
    // there should be no bundled dependencies in the plugin package.json
    // because they're in the bundle already.
    const normalizedPackageJSON = removeBundledDepsFromPackageJsonContents(packageJSONContents);
    // a .ts "main" will cause content-engine and gatsby to error.
    delete normalizedPackageJSON.main;
    let version;
    if (watchMode) {
        // changing the version in watch mode every time will cause the cache to be wiped out on every code save. Can't do that! If there's no version in package.json then allow it to be undefined.
        version = normalizedPackageJSON.version;
    }
    else {
        // if it's not watch mode then it's build mode, prefer the package.json version and fall back to the generated version if it's not there. A version is needed for the package to be published. Using Date.now() will mean each new release is numerically sortable as later than the last release.
        const randomString = Math.random().toString(36).substring(2, 7);
        version = `0.0.0-${randomString}`;
    }
    const name = `${config.slug}-connector`;
    await ensureDir(connectorDir);
    await copyFile(resolve(outDir, "index.js"), resolve(connectorDir, "index.js"));
    const sourceMapJSON = await fsExtra.readJSON(resolve(outDir, "index.js.map"));
    sourceMapJSON.sources = sourceMapJSON.sources.map((source) => join(`../`, source));
    await writeJSON(resolve(connectorDir, `index.js.map`), sourceMapJSON);
    await writeJSON(resolve(connectorDir, `package.json`), {
        ...normalizedPackageJSON,
        name,
        version,
    }, {
        spaces: 2,
    });
    await writeFile(resolve(connectorDir, `gatsby-node.js`), javascript `

      import { integration } from "./index.js";
      const { contentEngineImplementations } = integration.netlifyConnectPlugin;

      ${contentEngineApiNames
        .map((apiName) => javascript `export const ${apiName} = contentEngineImplementations.${apiName};`)
        .join(`\n`)}

    `);
    await integrationWorker.writeConnectorOptionsSchema();
    const connectorConfig = await integrationWorker.getConnectorConfig();
    const supportsCreate = connectorConfig?.supports?.create;
    if (watchMode && supportsCreate) {
        await writeStackbitDevFiles({
            connectorDir,
            integrationConfig: config,
        });
    }
    if (supportsCreate) {
        const rand = Math.random();
        await writeFile(resolve(connectorDir, `${rand}-index.js`), javascript `
        // the only purpose of this file is to prevent stackbit/esbuild from bundling ./index.js.
        // Since the name of this file is completely random, it can't statically determine
        // how to bundle it :)
        export * from "./index.js"
`);
        const templateDir = join(url.fileURLToPath(new URL(".", import.meta.url)), `templates/`);
        await copyFile(join(templateDir, `netlify-create.template.d.ts`), resolve(connectorDir, `netlify-create.d.ts`));
        const templateData = {
            integrationImportPath: (watchMode ? "../../" : `./`) + rand + "-index.js",
            configSlug: name,
        };
        const templateFile = readFileSync(join(templateDir, `./netlify-create.template.js`), {
            encoding: `utf8`,
        });
        const templateLines = templateFile.split(`\n`);
        const replaceAt = templateLines.findIndex((l) => l.startsWith(`const templateData = global`)) + 1;
        await writeFile(resolve(connectorDir, `netlify-create.js`), javascript `
        const templateData = ${JSON.stringify(templateData, null, 2)} 

        ${templateLines
            .slice(replaceAt)
            .map((line) => {
            if (!line.includes(`// programatically replaced with getContentEngineConfig() when building for production`)) {
                return line;
            }
            if (watchMode)
                return ``;
            // for production (!watchMode) specify content-engine options so that Stackbit will run the internal source-plugin
            return javascript `
                getContentEngineConfig() {
                  return {
                    connector: templateData.configSlug,
                    plugins: [
                      {
                        resolve: templateData.configSlug,
                        options: this.options || {}
                      }
                    ]
                  }
                }
        `;
        })
            .join(`\n`)}
`);
    }
    if (!watchMode) {
        execSync(`npm pack`, {
            cwd: connectorDir,
        });
        const packedFile = `${name
            .replaceAll("@", "")
            .replaceAll("/", "-")}-${version}.tgz`;
        await ensureDir(resolve(outDir, "site/static/packages"));
        await copyFile(resolve(outDir, `connector/${packedFile}`), resolve(outDir, "site/static/packages", "connector.tgz"));
    }
};
export function getConnectorLocalFrontendConfig(integrationConfig) {
    const localFrontendConfig = integrationConfig?.connector?.["local-frontend"];
    return localFrontendConfig || false;
}
export async function writeStackbitDevFiles({ connectorDir, integrationConfig, }) {
    const localFrontendConfig = getConnectorLocalFrontendConfig(integrationConfig);
    if (!localFrontendConfig) {
        ntliLog(`No local frontend configuration found in integration.yaml\nLocal Netlify Create will not run.`);
        return;
    }
    const createSSGPort = localFrontendConfig?.port ?? false;
    await writeFile(resolve(connectorDir, "content-engine-hooks.cjs"), javascript `
        const { start } = require('@stackbit/dev/dist/dev.js')

        start({
          ssgPort: ${createSSGPort || 3000},
          ssgHost: '127.0.0.1',
          rootDir: __dirname,
        })
`);
    let createConfigFilePath = undefined;
    if (localFrontendConfig?.directory) {
        const frontendPath = join(connectorDir, `../../`, localFrontendConfig.directory);
        const filesInPath = fsExtra.readdirSync(frontendPath);
        const configNames = filesInPath.filter((name) => name.startsWith(`stackbit.config.`));
        if (configNames.length > 1)
            throw new Error(`Found multiple Netlify Create configuration files (filenames starting with create.config.*). Only one is allowed.`);
        if (configNames.length) {
            createConfigFilePath = join(frontendPath, configNames[0]);
        }
    }
    await writeFile(resolve(connectorDir, `stackbit.config.ts`), javascript `
        import CreateConnector from './netlify-create.js'

        ${(() => {
        if (createConfigFilePath) {
            return javascript `
              import config from "${createConfigFilePath}"

              const contentSources = config.contentSources || []

              if (!contentSources.find(source => source instanceof CreateConnector)) {
                contentSources.push(new CreateConnector())
              }

              export default {
                ...config,
                contentSources
              }
          `;
        }
        else {
            return javascript `
              export default {
                stackbitVersion: '~0.6.0',
                nodeVersion: '18',
                contentSources: [
                  new CreateConnector()
                ]
              }
        `;
        }
    })()}
         
        `);
}
