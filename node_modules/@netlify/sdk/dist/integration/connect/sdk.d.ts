import { GraphQLSchema } from "graphql";
import * as CSITypes from "@stackbit/types";
import type { Schema } from "zod";
import zodLib from "zod";
import type { GatsbyNode as ContentEngineAPIs, SourceNodesArgs, PluginOptions } from "content-engine";
import { ModelBuilder, Modeler, ModelsIteratorObject } from "./model/builder.js";
import { ModelDefinition } from "./model/definition.js";
declare module "zod" {
    interface ZodMeta {
        [k: string | number | symbol]: unknown;
    }
    interface ZodTypeDef {
        meta?: ZodMeta;
    }
    interface ZodType<Output = any, Def extends zodLib.ZodTypeDef = zodLib.ZodTypeDef, Input = Output> {
        getMeta(): this["_def"] extends {
            meta: infer M;
        } ? M : ZodMeta | undefined;
        meta<T extends ZodMeta = ZodMeta>(meta: T): ZodType<Output, Def extends {
            meta: infer M;
        } ? Def & {
            meta: M & T;
        } : Def & {
            meta: T;
        }, Input>;
    }
}
export type ConnectorRuntimeState = Record<string, any>;
export type Supports = {
    create: boolean;
    deltaSync: boolean;
};
export type ConnectorConfig = {
    typePrefix: string;
    localDevOptions?: {
        [key: string]: string | boolean | number;
    };
    supports?: Partial<Supports>;
};
type ProxiedSchemaFn = (args: {
    options: Record<string, any>;
    typePrefix: string;
    state: ConnectorRuntimeState;
}) => Promise<GraphQLSchema>;
export type NetlifyConnectorInstance = InstanceType<typeof NetlifyConnector>;
export type NodesApi = Partial<SourceNodesArgs["actions"] & {
    createNodeId: SourceNodesArgs["createNodeId"];
    cache: SourceNodesArgs["cache"];
    pluginOptions: PluginOptions;
    webhookBody: Record<string, any>;
}>;
export interface Cache {
    get<T = unknown>(key: string): Promise<T>;
    set<T = unknown>(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
}
export interface ConnectorAPIUtils<State, OptionsType = Record<string, unknown>> {
    /**
     * The data source options passed to the connector (creds etc.)
     */
    options: OptionsType;
    /**
     * Mutable state. Can be used for e.g. API clients. Do not use to store document data.
     */
    state: State;
    /**
     * Cache to store data between builds, e.g. sync tokens. Do not use to store document data.
     */
    cache: Cache;
    /**
     * Platform that the connector is running on.
     */
    platform: PlatformType;
}
type CreateNodesPluginApi = (createAllNodesApi: {
    models: ModelsIteratorObject;
    cache: SourceNodesArgs["cache"];
    webhookBody: Record<string, any>;
}, pluginOptions: PluginOptions) => Promise<void> | void;
type DefinedImplementation = false | ((args?: any, options?: any) => Promise<any> | any);
type InvertedPromise = {
    resolve: (value?: unknown) => void;
    reject: (reason?: any) => void;
    promise: Promise<any> | undefined;
};
export type APIName = "sync" | "documents.update" | "documents.create" | "documents.delete" | "documents.publish" | "init" | "model" | "event.createAllNodes" | "event.updateNodes";
export type APIPromiseName = APIName | "runtime";
export type ConnectorInit = {
    state: Record<string, any>;
};
export type PlatformType = "netlify-connect" | "netlify-create" | "local" | "unknown";
export declare class NetlifyConnector<ConnectorContext extends ConnectorInit> {
    config: ConnectorConfig;
    contentEngineImplementations: Partial<ContentEngineAPIs>;
    apiPromises: Map<APIPromiseName, {
        connect: InvertedPromise;
        create: InvertedPromise;
    }>;
    private hasDefinedDocumentsImplementation;
    private cache?;
    private started;
    private warmCacheKey;
    private ModelBuilder;
    private nodesApi;
    private createApi;
    private schemaApi;
    definedImplementations: Map<APIName, DefinedImplementation>;
    private optionsSchema?;
    private optionsValues;
    private proxiedSchemas;
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    supports: Supports;
    private runtimeSupportsCreate;
    private runtimeState;
    private packageName;
    private syncCount;
    private isUsingUnifiedAPI;
    /**
     * As of January 24, 2023:
     *
     * Knowledge of what platform the connector is running on changes the logic that happens as part of Netlify Create.
     * As there might be other platforms that also need to change their behaviour based on the environment that the connector
     * is running in the future, we're storing this information in the connector instance.
     *
     */
    private platform;
    constructor(config: ConnectorConfig);
    _getLocales(): CSITypes.Locale[];
    _getProjectManageUrl(): string;
    private legacySync;
    private unifiedSync;
    private log;
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    init: (init: (args: Omit<ConnectorAPIUtils<any>, "state">) => Promise<ConnectorContext["state"] & {
        projectManageUrl?: string;
    }> | (ConnectorContext["state"] & {
        projectManageUrl?: string;
    })) => void;
    getAPIPromises(name: APIPromiseName): {
        connect: InvertedPromise;
        create: InvertedPromise;
    };
    /**
     * Defines the user configuration options for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#defineoptions
     */
    defineOptions: (definer: ({ zod }: {
        zod: typeof zodLib;
    }) => Schema<any>) => void;
    getOptionsSchema(): zodLib.ZodObject<{
        [x: string]: any;
    }, zodLib.UnknownKeysParam, zodLib.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>;
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler: Modeler<ConnectorContext["state"]>): void;
    sync(sync: (args: {
        models: ModelsIteratorObject;
        webhookBody: Record<string, any>;
        isInitialSync: boolean | null;
        state: ConnectorContext["state"];
        cache: Cache;
        options: Record<string, any>;
        platform: PlatformType;
    }) => Promise<void> | void): void;
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    documents<DocumentsType extends {
        userContext: unknown;
    }>(args: {
        update: (args: {
            document: any;
            model: ModelDefinition["dataAPI"];
            models: ModelBuilder["modelDataAPIs"];
            operations: CSITypes.UpdateOperation[];
            state: ConnectorContext["state"];
            cache: Cache;
            options: Record<string, any>;
            userContext: (CSITypes.User & DocumentsType["userContext"]) | undefined;
            platform: PlatformType;
        }) => Promise<void> | void;
        create: (args: {
            model: ModelDefinition["dataAPI"];
            models: ModelBuilder["modelDataAPIs"];
            updateOperationFields: Record<string, CSITypes.UpdateOperationField>;
            state: ConnectorContext["state"];
            cache: Cache;
            options: Record<string, any>;
            userContext: (CSITypes.User & DocumentsType["userContext"]) | undefined;
            platform: PlatformType;
        }) => Promise<{
            documentId: string;
        }> | {
            documentId: string;
        };
        delete: (args: {
            model: ModelDefinition["dataAPI"];
            models: ModelBuilder["modelDataAPIs"];
            state: ConnectorContext["state"];
            cache: Cache;
            options: Record<string, any>;
            document: any;
            userContext: (CSITypes.User & DocumentsType["userContext"]) | undefined;
            platform: PlatformType;
        }) => Promise<void> | void;
        publish: (args: {
            state: ConnectorContext["state"];
            cache: Cache;
            options: Record<string, any>;
            documents: any[];
            userContext: (CSITypes.User & DocumentsType["userContext"]) | undefined;
            platform: PlatformType;
        }) => Promise<void> | void;
    }): void;
    /**
     * Defines a data event. Supported events are `createAllNodes` and `updateNodes`.
     * @link https://sdk.netlify.com/connectors/connector-apis/#createallnodes
     */
    event(name: "createAllNodes" | "updateNodes", implementation: CreateNodesPluginApi | false): void;
    private shouldHandleCreateSupport;
    setRuntimeSupportsCreate(): void;
    private checkCanDefine;
    private wrapContentEngineApi;
    private getLmdbDatastore;
    restoreAllDocuments(): Promise<CSITypes.Document<unknown>[]>;
    restoreAllAssets(): Promise<CSITypes.Asset<unknown>[]>;
    proxySchema(fn: ProxiedSchemaFn): void;
}
export {};
