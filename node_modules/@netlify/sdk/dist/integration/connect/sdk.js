import { writeFile } from "fs/promises";
import path from "path";
import chalk from "chalk";
import zodLib from "zod";
import { register } from "zod-metadata";
register(zodLib);
import { catchMaybePromise } from "../../utils.js";
import { ModelBuilder, } from "./model/builder.js";
import { ConnectorOptionsSchema } from "./utils/options.js";
import { ModelError } from "./model/error.js";
import { builtInStackbitStringTypes, } from "./model/definition.js";
import { lmdbStoredAssetToStackbit, lmdbStoredDocumentToStackbit, } from "./utils/data.js";
export class NetlifyConnector {
    config;
    contentEngineImplementations = {}; // Content Engine APIs implemented by the plugin author
    apiPromises = new Map();
    hasDefinedDocumentsImplementation = false;
    cache;
    started = false; // true if the first event loop tick has occurred. Plugin APIs cannot be dynamically assigned after this as the "exports" should be static. so this value is checked before assigning plugin APIs. It must be false to assign plugin APIs.
    warmCacheKey = `netlify-connector-warm-cache`;
    ModelBuilder;
    nodesApi = { webhookBody: {} };
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    createApi = {};
    schemaApi = {};
    definedImplementations = new Map();
    optionsSchema;
    optionsValues = {};
    proxiedSchemas = [];
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    supports = {
        create: false,
        deltaSync: true,
    };
    runtimeSupportsCreate = false;
    runtimeState = {};
    packageName = ``;
    syncCount = 0;
    isUsingUnifiedAPI = false;
    /**
     * As of January 24, 2023:
     *
     * Knowledge of what platform the connector is running on changes the logic that happens as part of Netlify Create.
     * As there might be other platforms that also need to change their behaviour based on the environment that the connector
     * is running in the future, we're storing this information in the connector instance.
     *
     */
    platform = "unknown";
    constructor(config) {
        this.config = config;
        if (config.supports) {
            this.supports = {
                ...this.supports,
                ...config.supports,
            };
        }
        this.ModelBuilder = new ModelBuilder({
            nodesApi: this.nodesApi,
            createApi: this.createApi,
            supports: this.supports,
        });
        this.wrapContentEngineApi(`onPluginInit`)(async (helpers, pluginOptions) => {
            const cache = helpers.cache;
            this.cache = {
                get: cache.get.bind(cache),
                set: cache.set.bind(cache),
                delete: cache.del.bind(cache),
            };
            this.packageName =
                helpers.store.getState()?.program?.sitePackageJson?.name ||
                    `unknown`;
            if (this.optionsSchema) {
                try {
                    this.optionsSchema.validate(pluginOptions, this.packageName);
                }
                catch (e) {
                    if (e instanceof ModelError) {
                        console.error(e.message);
                    }
                    else {
                        console.error(e);
                    }
                    return delayedExit();
                }
            }
            this.optionsValues = pluginOptions;
            const startTime = Date.now();
            if (this.supports?.create) {
                // wait .5s for Create to start and respond to the runtime prom, otherwise assume there's no
                // Create runtime in the current process
                const { create } = this.getAPIPromises(`runtime`);
                const runtimeCreateTimeout = setTimeout(() => {
                    create.resolve(false);
                }, 500);
                await create.promise;
                clearTimeout(runtimeCreateTimeout);
            }
            if (process.env.SDK_ENV === "development") {
                this.platform = "local";
            }
            else if (process.env.RESOURCE_TYPE === "DATA_LAYER") {
                // The above env var is set in the Connect codebase itself
                this.platform = "netlify-connect";
            }
            else if (this.shouldHandleCreateSupport()) {
                this.platform = "netlify-create";
            }
            const { create, connect } = this.getAPIPromises(`init`);
            const init = this.definedImplementations.get(`init`);
            if (init) {
                await init(helpers, pluginOptions);
            }
            else {
                // allow the generated Create CSI to continue, it's waiting for init() to resolve this promise
                connect.resolve();
            }
            if (this.shouldHandleCreateSupport()) {
                const createAPI = await create.promise;
                if (createAPI) {
                    for (const key of Object.keys(createAPI)) {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        this.createApi[key] = createAPI[key];
                    }
                }
            }
            this.log(`initialized ${chalk.blue(Date.now() - startTime + `ms`)}`);
        });
        this.wrapContentEngineApi("sourceNodes")(async (args) => {
            const syncingLog = setTimeout(() => {
                this.log(`syncing`, {
                    symbol: `â§—`,
                    symbolColor: `yellow`,
                });
            }, 3000);
            const startTime = Date.now();
            if (this.isUsingUnifiedAPI) {
                await this.unifiedSync(args);
            }
            else {
                await this.legacySync(args);
            }
            clearTimeout(syncingLog);
            this.log(`synced ${this.syncCount} records ${chalk.blue(Date.now() - startTime + `ms`)}\n`);
        });
        this.wrapContentEngineApi(`createSchemaCustomization`)(async (schemaCustomizationApi) => {
            if (this.proxiedSchemas.length) {
                await Promise.all(this.proxiedSchemas?.map(async (fn) => {
                    const schema = (await fn({
                        options: this.optionsValues,
                        typePrefix: this.config.typePrefix,
                        state: this.runtimeState,
                    }));
                    schemaCustomizationApi.actions.addThirdPartySchema({
                        schema,
                    });
                }));
            }
            const modeler = this.definedImplementations.get(`model`);
            if (!modeler) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
            }
            if (this.supports.create) {
                // add builtin Create string-like types when Create support is enabled.
                schemaCustomizationApi.actions.createTypes(Array.from(builtInStackbitStringTypes.keys()).map((name) => schemaCustomizationApi.schema.buildScalarType({
                    name,
                    description: `Netlify Create ${name} String type`,
                    // don't add a serializer. input values should be strings already
                    // serialize: (nope) => nope,
                    // no need for the extra overhead that GraphQLString.serialize adds
                })));
            }
            this.schemaApi = schemaCustomizationApi;
            await modeler();
        });
        setImmediate(() => {
            // plugins may only add APIs on the first event loop tick.
            // exported APIs are static and cannot be dynamically assigned.
            this.started = true;
            if (!this.definedImplementations.has(`model`)) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
            }
            if ((this.definedImplementations.has(`event.updateNodes`) ||
                this.definedImplementations.has(`event.createAllNodes`)) &&
                this.definedImplementations.has(`sync`)) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`connector.event() and connector.documents() cannot both be used. If you're trying the new connector.documents() API, you must remove all calls to connector.event(). connector.documents({ sync: implementation }) has replaced all connector.event() calls.`);
            }
            if (!this.definedImplementations.has(`sync`) &&
                !this.definedImplementations.has(`event.createAllNodes`)) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                if (this.supports.create) {
                    throw new Error(`No connector.documents({ sync: implementation }) was defined. This API is required for all connectors.`);
                }
                else {
                    throw new Error(`No connector.event('createAllNodes', fn) implementation was defined. This API is required for all connectors.`);
                }
            }
        });
    }
    _getLocales() {
        return this.ModelBuilder.locales;
    }
    _getProjectManageUrl() {
        return this.runtimeState?.projectManageUrl || ``;
    }
    // for connectors that are using connector.event(name, impl) instead of the new unified connector API.
    // mostly needed in order to break up the unified API into smaller PR's and keep shipping small pieces
    async legacySync({ actions, cache, }) {
        const { enableStatefulSourceNodes } = actions;
        if (typeof enableStatefulSourceNodes !== `function`) {
            if (!this.proxiedSchemas.length) {
                // all versions of content-engine have this API.
                // not all versions of Gatsby do. Since connectors built with this API can theoretically be run by Gatsby as well, and old versions of Gatsby, we need to throw here if the API is not available.
                throw new Error(`Your version of Gatsby is too old to support this plugin. You need gatsby@>=5.9.0 or any version of content-engine.`);
            }
        }
        const createAllNodes = this.definedImplementations.get(`event.createAllNodes`);
        if (!createAllNodes) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No connector.createAllNodes(implementation) was defined. This API is required for all connectors.`);
        }
        const updateNodes = this.definedImplementations.get(`event.updateNodes`);
        // updateNodes may be set to false, so need to check undefined
        if (typeof updateNodes === `undefined`) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No updateNodes implementation was defined. All connectors should support incremental data fetching. If yours cannot, you can set this API to "false" so that maintainers see immediately that your plugin does no caching. ie:

connector.event('createAllNodes', () => {})
connector.event('updateNodes', false)
`);
        }
        if (updateNodes !== false) {
            // disables node garbage collection. Plugins must explicitly delete nodes themselves when they support incremental data updates.
            enableStatefulSourceNodes();
        }
        const isWarmCache = await cache.get(this.warmCacheKey);
        if (!isWarmCache) {
            await createAllNodes();
            await cache.set(this.warmCacheKey, true);
        }
        else {
            return (updateNodes || createAllNodes)();
        }
    }
    async unifiedSync({ actions, }) {
        const documentsSync = this.definedImplementations.get(`sync`);
        const cache = this.cache;
        if (!documentsSync) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No connector.documents({ sync: implementation }) was defined. This API is required for all connectors.`);
        }
        if (this.supports.deltaSync) {
            const { enableStatefulSourceNodes } = actions;
            if (typeof enableStatefulSourceNodes !== `function`) {
                throw new Error(`Could not enable delta syncing. This is a bug in content-engine.`);
            }
            // disables node garbage collection. Plugins must explicitly delete nodes themselves when they support delta syncing. This is the default behaviour
            enableStatefulSourceNodes();
        }
        const isDeltaSync = this.supports.deltaSync
            ? !!(await cache.get(this.warmCacheKey))
            : null;
        await documentsSync();
        if (!isDeltaSync && this.supports.deltaSync) {
            await cache.set(this.warmCacheKey, true);
        }
    }
    log(message, { symbolColor, symbol } = {}) {
        if (!symbolColor || !(symbolColor in chalk))
            symbolColor = `green`;
        if (!symbol)
            symbol = `->`;
        if (symbol.length === 1)
            symbol = `${symbol} `;
        const label = chalk.grey(this.packageName);
        console.log(`${label} \n ${chalk[symbolColor](symbol)} ${message}\n`);
    }
    // optional Connector apis:
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    init = (init) => {
        this.checkCanDefine(`init`);
        this.definedImplementations.set(`init`, async (helpers) => {
            const { connect } = this.getAPIPromises(`init`);
            const val = await init({
                options: this.optionsValues,
                cache: helpers.cache,
                platform: this.platform,
            });
            connect.resolve(val);
            if (val) {
                this.runtimeState = val;
            }
        });
    };
    getAPIPromises(name) {
        const existingPromises = this.apiPromises.get(name);
        if (existingPromises)
            return existingPromises;
        const inverts = {
            connect: makeInvertedPromise(),
            create: makeInvertedPromise(),
        };
        if (!this.supports?.create) {
            inverts.create.resolve();
        }
        this.apiPromises.set(name, inverts);
        inverts.create.promise?.finally(() => {
            inverts.create.promise = undefined;
            if (!inverts.create.promise)
                this.apiPromises.delete(name);
        });
        inverts.connect.promise?.finally(() => {
            inverts.connect.promise = undefined;
            if (!inverts.create.promise)
                this.apiPromises.delete(name);
        });
        return this.apiPromises.get(name);
    }
    /**
     * Defines the user configuration options for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#defineoptions
     */
    defineOptions = (definer) => {
        this.checkCanDefine(`defineOptions`);
        if (!definer || typeof definer !== `function`) {
            throw new Error(`The first argument in connector.defineOptions() must be a function that returns a zod object.`);
        }
        this.optionsSchema = new ConnectorOptionsSchema(definer);
    };
    getOptionsSchema() {
        // fallback to blank schema if no options were defined. there are default built in options that all connectors need, so if none are defined we need to make this empty one.
        this.optionsSchema ||= new ConnectorOptionsSchema(({ zod }) => zod.object({}));
        return this.optionsSchema.buildSchema();
    }
    // required Connector apis:
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler) {
        this.definedImplementations.set(`model`, async () => {
            const { connect } = this.getAPIPromises("model");
            const typePrefix = this.optionsValues?.typePrefix || this.config.typePrefix;
            const startTime = Date.now();
            const schemaCustomizationApi = this.schemaApi;
            const { sdl } = await this.ModelBuilder.build({
                modeler,
                typePrefix,
                cache: schemaCustomizationApi.cache,
                configurationOptions: this.optionsValues,
                state: this.runtimeState,
                shouldAutoRenameFieldsAndModels: !this?.supports?.create,
                platform: this.platform,
            });
            schemaCustomizationApi.actions.createTypes(sdl);
            if (process.env.NODE_ENV === `development` ||
                process.env.NODE_ENV === `test`) {
                await writeFile(path.join(process.cwd(), `dev-model.gql`), `# this file is automatically generated. Its only purpose is for debugging and understanding how your model definitions translate to GraphQL\n\n${sdl}`);
            }
            this.log(`defined ${this.ModelBuilder.models.size} models ${chalk.blue(Date.now() - startTime + `ms`)}`);
            connect.resolve(this.ModelBuilder);
        });
    }
    sync(sync) {
        this.checkCanDefine(`sync`);
        if (this.definedImplementations.has(`sync`)) {
            throw new ModelError(`connector.sync() may only be called one time, but has been called more than once.`);
        }
        this.isUsingUnifiedAPI = true;
        this.definedImplementations.set(`sync`, async () => {
            const { connect } = this.getAPIPromises(`sync`);
            const models = this.ModelBuilder.modelDataAPIs;
            const cache = this.cache;
            const options = this.nodesApi.pluginOptions;
            const webhookBody = this.nodesApi.webhookBody || {};
            if (!models || !cache || !options) {
                throw new Error(`Cannot invoke events before models have been defined.`);
            }
            const isDeltaSync = !!(await cache.get(this.warmCacheKey));
            await sync({
                models,
                cache,
                webhookBody,
                isInitialSync: !isDeltaSync,
                state: this.runtimeState,
                options,
                platform: this.platform,
            });
            connect.resolve();
        });
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    documents(args) {
        this.checkCanDefine(`documents`);
        if (this.hasDefinedDocumentsImplementation) {
            throw new ModelError(`connector.documents() may only be called one time, but has been called more than once.`);
        }
        else {
            this.hasDefinedDocumentsImplementation = true;
        }
        this.isUsingUnifiedAPI = true;
        if (args.update) {
            const update = args.update;
            this.definedImplementations.set(`documents.update`, ({ document, operations, userContext, }) => {
                const model = this.ModelBuilder.modelDataAPIs[document?.modelName?.replace(this.ModelBuilder.typePrefix, ``)];
                if (!model) {
                    throw new ModelError(`No model found with name ${document.modelName}`);
                }
                return update({
                    model,
                    models: this.ModelBuilder.modelDataAPIs,
                    document,
                    state: this.runtimeState,
                    cache: this.cache,
                    options: this.optionsValues,
                    operations,
                    userContext,
                    platform: this.platform,
                });
            });
        }
        if (args.create) {
            const create = args.create;
            this.definedImplementations.set(`documents.create`, async ({ model: stackbitModel, updateOperationFields, userContext, }) => {
                const unprefixedModelName = stackbitModel.name.replace(this.ModelBuilder.typePrefix, ``);
                const model = this.ModelBuilder.models.get(unprefixedModelName);
                if (!model) {
                    throw new ModelError(`No model found with name ${stackbitModel.name}`);
                }
                const connectorReturnedVal = await create({
                    model: model.dataAPI,
                    models: this.ModelBuilder.modelDataAPIs,
                    state: this.runtimeState,
                    options: this.optionsValues,
                    cache: this.cache,
                    updateOperationFields,
                    userContext,
                    platform: this.platform,
                });
                return connectorReturnedVal;
            });
        }
        if (args.delete) {
            const del = args.delete;
            this.definedImplementations.set(`documents.delete`, ({ document, userContext, }) => {
                const model = this.ModelBuilder.modelDataAPIs[document?.modelName?.replace(this.ModelBuilder.typePrefix, ``)];
                if (!model) {
                    throw new ModelError(`No model found with name ${document?.modelName}`);
                }
                return del({
                    model,
                    models: this.ModelBuilder.modelDataAPIs,
                    cache: this.cache,
                    options: this.optionsValues,
                    document,
                    state: this.runtimeState,
                    userContext,
                    platform: this.platform,
                });
            });
        }
        if (args.publish) {
            const publish = args.publish;
            this.definedImplementations.set(`documents.publish`, ({ documents, userContext, }) => {
                return publish({
                    documents,
                    options: this.optionsValues,
                    cache: this.cache,
                    state: this.runtimeState,
                    userContext,
                    platform: this.platform,
                });
            });
        }
    }
    /**
     * Defines a data event. Supported events are `createAllNodes` and `updateNodes`.
     * @link https://sdk.netlify.com/connectors/connector-apis/#createallnodes
     */
    event(name, implementation) {
        if (this.definedImplementations.has(`event.${name}`)) {
            throw new ModelError(`connector.event('${name}', implementation) was already defined. You may only define each event once.`);
        }
        this.definedImplementations.set(`event.${name}`, () => {
            const models = this.ModelBuilder.modelDataAPIs;
            const cache = this.nodesApi.cache;
            const pluginOptions = this.nodesApi.pluginOptions;
            const webhookBody = this.nodesApi.webhookBody || {};
            if (!models || !cache || !pluginOptions) {
                throw new Error(`Cannot invoke events before models have been defined.`);
            }
            if (name === `updateNodes` && implementation === false) {
                const createAllNodes = this.definedImplementations.get(`event.createAllNodes`);
                if (!createAllNodes) {
                    throw new Error(`Cannot set updateNodes to false if createAllNodes is not defined.`);
                }
                return createAllNodes();
            }
            if (implementation === false) {
                throw new Error(`Cannot set ${name} to false.`);
            }
            return implementation({
                models,
                cache,
                webhookBody,
            }, pluginOptions);
        });
    }
    shouldHandleCreateSupport() {
        return this.config?.supports?.create && this.runtimeSupportsCreate;
    }
    setRuntimeSupportsCreate() {
        if (this.config?.supports?.create) {
            this.runtimeSupportsCreate = true;
            this.getAPIPromises(`runtime`).create.resolve();
        }
    }
    checkCanDefine(apiName) {
        if (this.started) {
            throw new Error(`Cannot call ${apiName} after the first event loop tick.\n\nPlease call connector().${apiName}() synchronously in your plugin's main module. Plugin implementations cannot be dynamically assigned.`);
        }
    }
    wrapContentEngineApi(apiName) {
        return (pluginApiImplementation) => {
            this.checkCanDefine(apiName);
            this.contentEngineImplementations[apiName] = ((arg1, arg2) => {
                try {
                    if (apiName === `sourceNodes`) {
                        this.syncCount = 0;
                        this.nodesApi.createNode = (args) => {
                            this.syncCount++;
                            return arg1.actions.createNode(args);
                        };
                        this.nodesApi.deleteNode = (args) => {
                            this.syncCount++;
                            return arg1.actions.deleteNode(args);
                        };
                        this.nodesApi.createNodeId = arg1.createNodeId;
                        this.nodesApi.cache = arg1.cache;
                        this.nodesApi.pluginOptions = arg2;
                        this.nodesApi.webhookBody = arg1.webhookBody || {};
                    }
                    const cleanup = () => {
                        this.nodesApi.createNode = undefined;
                        this.nodesApi.deleteNode = undefined;
                        this.nodesApi.cache = undefined;
                        this.nodesApi.pluginOptions = undefined;
                    };
                    return catchMaybePromise(
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore types are wrong, third arg is not required and not needed
                    pluginApiImplementation(arg1, arg2), async (error) => {
                        console.error(error instanceof ModelError ? error.message : error);
                        return delayedExit();
                    }, () => {
                        cleanup();
                    });
                }
                catch (e) {
                    if (e instanceof ModelError) {
                        console.error(e.message);
                    }
                    else if (e instanceof Error) {
                        console.error(e.stack);
                    }
                    else {
                        console.error(e);
                    }
                    return delayedExit();
                }
            });
        };
    }
    async getLmdbDatastore() {
        const { getLmdbStore } = (await import(
        // content-engine is an external dep of the SDK, and the same content-engine instance must be used between Stackbit and the SDK
        // this is a non-statically analyzable import so stackbit can't bundle it in esbuild
        `content-engine/dist/datastore/lmdb/lmdb-datastore.js?${Math.random()}`));
        const datastore = getLmdbStore();
        await datastore.ready();
        return datastore;
    }
    async restoreAllDocuments() {
        const datastore = await this.getLmdbDatastore();
        const allDocuments = [];
        for (const [name, definition] of this.ModelBuilder.models) {
            if (name === `Image`)
                continue;
            const nodesOfModelType = datastore.getNodesByType(definition.prefixedTypeName());
            nodesOfModelType.forEach((n) => allDocuments.push(lmdbStoredDocumentToStackbit(n, definition)));
        }
        return allDocuments;
    }
    async restoreAllAssets() {
        // @todo: this should be a built in model - maybe Asset though, not Image?
        const definition = this.ModelBuilder.models.get(`Image`);
        if (!definition)
            return [];
        const nodesOfModelType = (await this.getLmdbDatastore()).getNodesByType(definition.prefixedTypeName());
        return nodesOfModelType.map(lmdbStoredAssetToStackbit);
    }
    proxySchema(fn) {
        this.proxiedSchemas.push(fn);
    }
}
function delayedExit(ms = 100) {
    return new Promise(() => {
        setTimeout(() => {
            // leave a bit of time to print large errors before exiting
            process.exit(1);
        }, ms);
    });
}
function makeInvertedPromise() {
    let resolve = () => { };
    let reject = () => { };
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return {
        resolve,
        reject,
        promise: promise,
    };
}
