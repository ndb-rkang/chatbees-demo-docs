import readline from "readline";
import { spawn } from "child_process";
import chalk from "chalk";
import open from "open";
import { getSettings, updateSettings } from "../util.js";
import { ntliLog, printResetHeader } from "../../utils.js";
import { getConnectorLocalFrontendConfig, } from "../../integration/connect/cli.js";
import { build } from "./build.js";
import { preview } from "./preview.js";
export const dev = async (opts) => {
    process.env.NODE_ENV = `development`;
    if (!opts.all && !opts.buildtime && !opts.site && !opts.connector) {
        // default to building everything when there are no flags set
        opts.all = true;
    }
    const buildApi = await build({
        ...opts,
        watch: true,
    });
    if (!buildApi || !buildApi.integration.netlifyConnectPlugin) {
        if (opts.connector) {
            throw new Error(`No Connector found`);
        }
        return;
    }
    const { startEngine } = await preview({
        ...opts,
        dev: true,
        connector: opts.connector || opts.all,
        // force disabled for now as the UI code doesn't support dev mode yet
        ui: false,
    });
    if ((opts.connector || opts.all) && startEngine) {
        handleConnectorPlugin({ buildApi, startEngine });
    }
};
export let connectorDevMode = getSettings()?.connectorDevMode || `clear cache on save`;
const handleConnectorPlugin = async ({ buildApi, startEngine, }) => {
    const supportsNetlifyCreate = !!buildApi.integration.netlifyConnectPlugin?.supports?.create;
    ntliLog("connector");
    const engine = await startEngine();
    const localFrontendConfig = getConnectorLocalFrontendConfig(buildApi.config);
    if (supportsNetlifyCreate) {
        handleFrontendProcess(localFrontendConfig);
    }
    handleConnectorKeypressListener({
        engine,
        supportsNetlifyCreate,
        localFrontendConfig,
    });
    logMode(supportsNetlifyCreate, localFrontendConfig);
    buildApi.onRebuild(async () => {
        // restart content engine with the new bundle.
        // the engine runs in a worker thread and
        // calling .restart() will kill the worker and
        // start a new one that uses the new bundle that was just built.
        ntliLog(`connector`);
        await engine.stop();
        if (connectorDevMode === `rebundle-only on save`) {
            engine.initialize().then(() => {
                logMode(supportsNetlifyCreate, localFrontendConfig);
            });
        }
        else {
            engine
                .sync({
                runServer: true,
                clearCache: connectorDevMode === `clear cache on save`,
            })
                .then(() => {
                logMode(supportsNetlifyCreate, localFrontendConfig);
            });
        }
    });
};
let connectorKeypressListenerAdded = false;
export const handleConnectorKeypressListener = ({ engine, supportsNetlifyCreate, localFrontendConfig, }) => {
    const createLocalDev = localFrontendConfig && supportsNetlifyCreate
        ? localFrontendConfig
        : undefined;
    if (!connectorKeypressListenerAdded) {
        connectorKeypressListenerAdded = true;
        readline.emitKeypressEvents(process.stdin);
        process.stdin.setRawMode(true);
        const urls = {
            connect: `http://localhost:8000/__graphql`,
            create: supportsNetlifyCreate ? `http://localhost:8090/_stackbit` : null,
            framework: createLocalDev?.port
                ? `http://localhost:${createLocalDev.port}`
                : null,
        };
        process.stdin.on("keypress", (_str, key) => {
            if (key.name === "o") {
                open(urls.connect);
            }
            else if (urls.create && key.name === "c" && !key.ctrl) {
                open(urls.create);
            }
            else if (urls.framework && key.name === "f") {
                open(urls.framework);
            }
            else if (Object.keys(urls).length > 1 && key.name === "a") {
                for (const url of Object.values(urls)) {
                    if (url)
                        open(url);
                }
            }
            else if (key.name === "m") {
                if (connectorDevMode === `clear cache on save`) {
                    connectorDevMode = `data update on save`;
                }
                else if (connectorDevMode === `data update on save`) {
                    connectorDevMode = `rebundle-only on save`;
                }
                else if (connectorDevMode === `rebundle-only on save`) {
                    connectorDevMode = `clear cache on save`;
                }
                updateSettings({ connectorDevMode });
                console.log(getModeLog());
            }
            else if ((key.ctrl && key.name === "c") || key.name === "q") {
                process.exit(); // If user presses CTRL+C, exit the process
            }
            else if (key.name === "r") {
                printResetHeader();
                ntliLog(`connector`);
                engine
                    .restart({
                    runServer: true,
                    clearCache: connectorDevMode === `clear cache on save`,
                })
                    .then(() => {
                    logMode(supportsNetlifyCreate, localFrontendConfig);
                });
            }
            else if (key.name === "s") {
                console.log("");
                ntliLog(`syncing connector`);
                engine.sync();
            }
        });
    }
};
const getModeLog = () => `${chalk.grey(`[m]`)} mode (${connectorDevMode === `clear cache on save`
    ? chalk.yellow(connectorDevMode)
    : connectorDevMode === `rebundle-only on save`
        ? chalk.blue(connectorDevMode)
        : chalk.green(connectorDevMode)})`;
const logMode = (supportsCreate, localFrontendConfig) => {
    console.log(chalk.blue(`Keys:`));
    console.log(getModeLog());
    console.log(`${chalk.grey(`[r]`)} restart process`);
    console.log(`${chalk.grey(`[s]`)} sync data\n`);
    console.log(chalk.blue(`Open:`));
    if (supportsCreate) {
        console.log(`${chalk.grey(`[c]`)} Netlify Create`);
    }
    console.log(`${chalk.grey(`[o]`)} Netlify Connect API`);
    if (supportsCreate && localFrontendConfig && localFrontendConfig?.command) {
        console.log(`${chalk.grey(`[f]`)} frontend app`);
    }
    if (supportsCreate) {
        console.log(`${chalk.grey(`[a]`)} all\n`);
    }
    else {
        console.log(``);
    }
};
async function handleFrontendProcess(localFrontendConfig) {
    if (!localFrontendConfig) {
        return;
    }
    const { command, directory, port } = localFrontendConfig || {};
    if (!command || !port) {
        console.warn(`When using integration.yaml connector.local-frontend you must provide a port and command. \n\nFound: ${JSON.stringify(localFrontendConfig, null, 2)}\nSkipping create local dev settings\n`);
        return;
    }
    const [bin, ...args] = command.split(` `);
    const frameworkP = spawn(bin, args, {
        stdio: `pipe`,
        cwd: directory || process.cwd(),
        detached: true,
    });
    let sawFirstCompileLog = false;
    frameworkP.stdout.on(`data`, (message) => {
        message = message.toString();
        if (message.startsWith(`- `)) {
            message = message.substring(2, message.length);
        }
        // omit ugly/noisy nextjs logs
        if (message.includes(`compiling /`))
            return;
        if (message.includes(`compiled client and server successfully`)) {
            if (!sawFirstCompileLog) {
                sawFirstCompileLog = true;
                return;
            }
            // for compiled still print a more minimal log
            process.stdout.write(chalk.yellow(`frontend`) + `: compiled\n`);
            return;
        }
        if (message.includes(`started server on`) && message.includes(`:${port}`)) {
            return;
        }
        if (message.includes(`> next`) &&
            message.includes(`@`) &&
            message.includes(` dev /`))
            return;
        process.stdout.write(chalk.yellow(`frontend`) + `: ${message}`);
    });
    frameworkP.stderr.on(`data`, (message) => {
        message = message.toString();
        if (message.startsWith(`- `)) {
            message = message.substring(2, message.length);
        }
        if (message.includes(`Fast Refresh had to perform a full reload.`))
            return;
        process.stderr.write(chalk.red(`frontend`) + `: ${message}`);
    });
    const { pid } = frameworkP;
    // kill frameworkP and all it's children when this process exits
    process.on("exit", async () => {
        if (pid) {
            process.kill(-pid);
        }
    });
}
